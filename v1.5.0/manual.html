<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Manual · The MicroFloatingPoints Documentation</title><meta name="title" content="Manual · The MicroFloatingPoints Documentation"/><meta property="og:title" content="Manual · The MicroFloatingPoints Documentation"/><meta property="twitter:title" content="Manual · The MicroFloatingPoints Documentation"/><meta name="description" content="Documentation for The MicroFloatingPoints Documentation."/><meta property="og:description" content="Documentation for The MicroFloatingPoints Documentation."/><meta property="twitter:description" content="Documentation for The MicroFloatingPoints Documentation."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">The MicroFloatingPoints Documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><a class="tocitem" href="guided-tour.html">A Guided Tour</a></li><li class="is-active"><a class="tocitem" href="manual.html">Manual</a><ul class="internal"><li><a class="tocitem" href="#The-MicroFloatingPoints-module"><span>The <code>MicroFloatingPoints</code> module</span></a></li><li><a class="tocitem" href="#The-MicroFloatingPoints.MFPUtils-module"><span>The <code>MicroFloatingPoints.MFPUtils</code> module</span></a></li><li><a class="tocitem" href="#The-MicroFloatingPoints.MFPRandom-module"><span>The <code>MicroFloatingPoints.MFPRandom</code> module</span></a></li><li><a class="tocitem" href="#The-MicroFloatingPoints.MFPPlot-module"><span>The <code>MicroFloatingPoints.MFPPlot</code> module</span></a></li></ul></li><li><a class="tocitem" href="developer.html">Developer Documentation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="manual.html">Manual</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="manual.html">Manual</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/goualard-f/MicroFloatingPoints.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/goualard-f/MicroFloatingPoints.jl/blob/main/docs/src/manual.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Manual"><a class="docs-heading-anchor" href="#Manual">Manual</a><a id="Manual-1"></a><a class="docs-heading-anchor-permalink" href="#Manual" title="Permalink"></a></h1><h2 id="The-MicroFloatingPoints-module"><a class="docs-heading-anchor" href="#The-MicroFloatingPoints-module">The <code>MicroFloatingPoints</code> module</a><a id="The-MicroFloatingPoints-module-1"></a><a class="docs-heading-anchor-permalink" href="#The-MicroFloatingPoints-module" title="Permalink"></a></h2><p>The central element of the <code>MicroFloatingPoints</code> package is the floating-point type <code>Floatmu</code>; it is parameterized by the sizes of the exponent field and the fractional part field.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroFloatingPoints.Floatmu" href="#MicroFloatingPoints.Floatmu"><code>MicroFloatingPoints.Floatmu</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Floatmu{szE,szf} &lt;: AbstractFloat</code></pre><p>IEEE 754-compliant floating-point number with <code>szE</code> bits for the exponent  and <code>szf</code> bits for the fractional part.</p><p>A <code>Floatmu</code> object must always have a precision smaller or equal to that of a single precision float. As a consequence, the following constraints hold:</p><p class="math-container">\[\left\{\begin{array}{l}
\text{szE}\in[2,8]\\
\text{szf}\in[2,23]
\end{array}\right.\]</p><p><strong>Examples</strong></p><p>Creating a <code>Floatmu</code> type equivalent to <code>Float32</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; MyFloat32 = Floatmu{8,23}
Floatmu{8, 23}

julia&gt; a=MyFloat32(0.1)
0.1

julia&gt; a == 0.1f0
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goualard-f/MicroFloatingPoints.jl/blob/458829d22193a414d0ba7bee53b06b7185905eb8/src/Floatmu.jl#L58-L85">source</a></section></article><h3 id="Creating-a-Floatmu-float"><a class="docs-heading-anchor" href="#Creating-a-Floatmu-float">Creating a <code>Floatmu</code> float</a><a id="Creating-a-Floatmu-float-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-a-Floatmu-float" title="Permalink"></a></h3><p>A <code>Floatmu</code> object may be created from a float from a standard floating-point type (<code>Float16</code>, <code>Float32</code>, <code>Float64</code>).</p><pre><code class="language-julia-repl hljs">julia&gt; Floatmu{8,23}(Float16(0.1))
0.099975586
julia&gt; Floatmu{8,23}(0.1f0)
0.1
julia&gt; Floatmu{8,23}(0.1)
0.1</code></pre><p>Note that, depending on the value and the size of the <code>Floatmu</code> type, some rounding may occur. </p><pre><code class="language-julia-repl hljs">julia&gt; Floatmu{2,2}(0.1f0)
0.0
julia&gt; Floatmu{8,7}(0.1f0)
0.1</code></pre><p>Each <code>Floatmu</code> object retains the sign of the error due to rounding the value used to create it. That sign may be obtained with the method <code>errorsign</code>. If one is only interested in obtaining a boolean to know whether some rounding took place or not, one can use the <code>isinexact</code> method instead.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroFloatingPoints.errorsign-Union{Tuple{Floatmu{szE, szf}}, Tuple{szf}, Tuple{szE}} where {szE, szf}" href="#MicroFloatingPoints.errorsign-Union{Tuple{Floatmu{szE, szf}}, Tuple{szf}, Tuple{szE}} where {szE, szf}"><code>MicroFloatingPoints.errorsign</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">errorsign(x::Floatmu{szE,szf}) where {szE,szf}</code></pre><p>Return <code>1</code> if <code>x</code> was rounded by excess when created as a <code>Floatmu{szE,szf}</code>, <code>-1</code> if it was rounded by default, and <code>0</code> if no rounding took place.</p><p>An NaN is never in error. An infinite is in error only if created from a finite value.</p><p><strong>See</strong></p><ul><li><a href="manual.html#MicroFloatingPoints.isinexact-Union{Tuple{Floatmu{szE, szf}}, Tuple{szf}, Tuple{szE}} where {szE, szf}"><code>isinexact(x::Floatmu{szE,szf}) where {szE,szf}</code></a></li><li><a href="manual.html#MicroFloatingPoints.reset_inexact-Tuple{}"><code>reset_inexact()</code></a></li><li><a href="manual.html#MicroFloatingPoints.inexact-Tuple{}"><code>inexact()</code></a></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; errorsign(Floatmu{2, 2}(0.5))
0
julia&gt; errorsign(Floatmu{2, 2}(1.7))
1
julia&gt; errorsign(Floatmu{2, 2}(-2.8))
-1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goualard-f/MicroFloatingPoints.jl/blob/458829d22193a414d0ba7bee53b06b7185905eb8/src/Floatmu.jl#L1199-L1223">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroFloatingPoints.isinexact-Union{Tuple{Floatmu{szE, szf}}, Tuple{szf}, Tuple{szE}} where {szE, szf}" href="#MicroFloatingPoints.isinexact-Union{Tuple{Floatmu{szE, szf}}, Tuple{szf}, Tuple{szE}} where {szE, szf}"><code>MicroFloatingPoints.isinexact</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isinexact(x::Floatmu{szE,szf}) where {szE,szf}</code></pre><p>Return <code>true</code> if the value <code>x</code> was rounded when created as a <code>Floatmu{szE,szf}</code> and  <code>false</code> otherwise.</p><p>An NaN is never inexact. An infinite is inexact only if created from a finite value.</p><p><strong>See:</strong></p><ul><li><a href="manual.html#MicroFloatingPoints.errorsign-Union{Tuple{Floatmu{szE, szf}}, Tuple{szf}, Tuple{szE}} where {szE, szf}"><code>errorsign(x::Floatmu{szE,szf}) where {szE,szf}</code></a>.</li><li><a href="manual.html#MicroFloatingPoints.reset_inexact-Tuple{}"><code>reset_inexact()</code></a></li><li><a href="manual.html#MicroFloatingPoints.inexact-Tuple{}"><code>inexact()</code></a></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; isinexact(Floatmu{2, 2}(0.25)+Floatmu{2, 2}(2.0))
true
julia&gt; isinexact(Floatmu{2, 2}(0.25)+Floatmu{2, 2}(1.5))
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goualard-f/MicroFloatingPoints.jl/blob/458829d22193a414d0ba7bee53b06b7185905eb8/src/Floatmu.jl#L1172-L1193">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Rounding information</header><div class="admonition-body"><p>Be wary of the fact that a <code>Floatmu</code> object is completely oblivious to rounding  that may have occurred <em>before</em> the call of its constructor. </p><pre><code class="language-julia hljs">julia&gt; isinexact(Floatmu{8,23}(Float16(0.1)))
false</code></pre><p>In the preceding example, no rounding is reported even though <code>0.1</code> is not  representable in binary because the <code>Floatmu</code> is created from a <code>Float16</code>  approximation of it and a <code>Floatmu{8,23}</code> object has more precision than  a <code>Float16</code>. The rounding that took place when creating the <code>Float16</code> in the first place goes unreported.</p></div></div><p>It is also possible to create a <code>Floatmu</code> float from an integer of the type <code>Int64</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; Floatmu{8,7}(10)
10.0</code></pre><p>Due to the limited range of the <code>Floatmu</code> type, some rounding may still occur:</p><pre><code class="language-julia-repl hljs">julia&gt; Floatmu{8,7}(303)
304.0</code></pre><p>It is possible to know the largest positive integer such that all smaller integers are represented without rounding using the <a href="https://docs.julialang.org/en/v1/base/base/#Base.maxintfloat"><code>Base.maxintfloat</code></a> method:</p><pre><code class="language-julia-repl hljs">julia&gt; maxintfloat(Floatmu{8,7})
256.0
julia&gt; Floatmu{8,7}(257)
256.0</code></pre><p>Lastly, a <code>Floatmu</code> may be created from another <code>Floatmu</code> with the same or a different precision and range.</p><pre><code class="language-julia-repl hljs">julia&gt; Floatmu{5,10}(0.1)==Floatmu{8,7}(Floatmu{5,10}(0.1))
false</code></pre><h3 id="Characteristics-of-a-Floatmu"><a class="docs-heading-anchor" href="#Characteristics-of-a-Floatmu">Characteristics of a <code>Floatmu</code></a><a id="Characteristics-of-a-Floatmu-1"></a><a class="docs-heading-anchor-permalink" href="#Characteristics-of-a-Floatmu" title="Permalink"></a></h3><p>It is possible to obtain some characteristics of a <code>Floatmu</code> type by using standard Julia methods. Most of them are usually undocumented, being internal to the <code>Base</code> package. Since the intended audience for the <code>MicroFloatingPoints</code> package is probably more interested in these methods than the general public, we document them here.</p><p>The <a href="https://docs.julialang.org/en/v1/base/numbers/#Base.precision"><code>Base.precision()</code></a> method returns the number of bits in the significand:</p><pre><code class="language-julia-repl hljs">julia&gt; Base.precision(Floatmu{8,23})
24</code></pre><p>The <code>Base.exponent_max</code> and <code>Base.exponent_raw_max</code> return, respectively, the maximum unbiased exponent and the maximum biased exponent. </p><pre><code class="language-julia-repl hljs">julia&gt; Base.exponent_max(Floatmu{8,23})
127
julia&gt; Base.exponent_raw_max(Floatmu{8,23})
255</code></pre><p>Some other methods in the <code>MicroFloatingPoints</code> package are related to the exponent of a <code>Floatmu</code>:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroFloatingPoints.Emax-Union{Tuple{Type{Floatmu{szE, szf}}}, Tuple{szf}, Tuple{szE}} where {szE, szf}" href="#MicroFloatingPoints.Emax-Union{Tuple{Type{Floatmu{szE, szf}}}, Tuple{szf}, Tuple{szE}} where {szE, szf}"><code>MicroFloatingPoints.Emax</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Emax(::Type{Floatmu{szE,szf}}) where {szE, szf}</code></pre><p>Maximum unbiased exponent for a <code>Floatmu{szE,szf}</code> returned as an <code>UInt32</code>.</p><p>See: <code>exponent_max</code>, <code>exponent_raw_max</code>, <a href="manual.html#MicroFloatingPoints.Emin-Union{Tuple{Type{Floatmu{szE, szf}}}, Tuple{szf}, Tuple{szE}} where {szE, szf}"><code>Emin</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Emax(Floatmu{8, 23})
0x0000007f</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goualard-f/MicroFloatingPoints.jl/blob/458829d22193a414d0ba7bee53b06b7185905eb8/src/Floatmu.jl#L205-L218">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroFloatingPoints.Emin-Union{Tuple{Type{Floatmu{szE, szf}}}, Tuple{szf}, Tuple{szE}} where {szE, szf}" href="#MicroFloatingPoints.Emin-Union{Tuple{Type{Floatmu{szE, szf}}}, Tuple{szf}, Tuple{szE}} where {szE, szf}"><code>MicroFloatingPoints.Emin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Emin(::Type{Floatmu{szE,szf}}) where {szE, szf}</code></pre><p>Minimum unbiased exponent for a <code>Floatmu{szE,szf}</code> returned as an <code>Int32</code>.</p><p>See: <code>exponent_max</code>, <code>exponent_raw_max</code>, <a href="manual.html#MicroFloatingPoints.Emax-Union{Tuple{Type{Floatmu{szE, szf}}}, Tuple{szf}, Tuple{szE}} where {szE, szf}"><code>Emax</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Emin(Floatmu{8, 23})
-126</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goualard-f/MicroFloatingPoints.jl/blob/458829d22193a414d0ba7bee53b06b7185905eb8/src/Floatmu.jl#L237-L250">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroFloatingPoints.bias-Union{Tuple{Type{Floatmu{szE, szf}}}, Tuple{szf}, Tuple{szE}} where {szE, szf}" href="#MicroFloatingPoints.bias-Union{Tuple{Type{Floatmu{szE, szf}}}, Tuple{szf}, Tuple{szE}} where {szE, szf}"><code>MicroFloatingPoints.bias</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bias(::Type{Floatmu{szE,szf}}) where {szE, szf}</code></pre><p>Bias of the exponent for a <code>Floatmu{szE,szf}</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; bias(Floatmu{8, 23}) 
0x0000007f</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goualard-f/MicroFloatingPoints.jl/blob/458829d22193a414d0ba7bee53b06b7185905eb8/src/Floatmu.jl#L253-L264">source</a></section></article><p>Other methods return remarkable values for the type:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroFloatingPoints.Infμ-Union{Tuple{Type{Floatmu{szE, szf}}}, Tuple{szf}, Tuple{szE}} where {szE, szf}" href="#MicroFloatingPoints.Infμ-Union{Tuple{Type{Floatmu{szE, szf}}}, Tuple{szf}, Tuple{szE}} where {szE, szf}"><code>MicroFloatingPoints.Infμ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Infμ(::Type{Floatmu{szE,szf}}) where {szE,szf}</code></pre><p>Positive infinite value in the format <code>Floatmu{szE,szf}</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Infμ(Floatmu{8, 23}) == Inf32
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goualard-f/MicroFloatingPoints.jl/blob/458829d22193a414d0ba7bee53b06b7185905eb8/src/Floatmu.jl#L267-L277">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroFloatingPoints.NaNμ-Union{Tuple{Type{Floatmu{szE, szf}}}, Tuple{szf}, Tuple{szE}} where {szE, szf}" href="#MicroFloatingPoints.NaNμ-Union{Tuple{Type{Floatmu{szE, szf}}}, Tuple{szf}, Tuple{szE}} where {szE, szf}"><code>MicroFloatingPoints.NaNμ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">NaNμ(::Type{Floatmu{szE,szf}}) where {szE, szf}</code></pre><p>NaN in the format <code>Floatmu{szE,szf}</code>.</p><p>The canonical NaN value has a sign bit set to zero and all bits of the fractional part set to zero except for the leftmost one.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; isnan(NaNμ(Floatmu{2, 2}))
true
julia&gt; NaNμ(Floatmu{2, 2})
NaNμ{2, 2}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goualard-f/MicroFloatingPoints.jl/blob/458829d22193a414d0ba7bee53b06b7185905eb8/src/Floatmu.jl#L280-L295">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Math.ldexp-Union{Tuple{szf}, Tuple{szE}, Tuple{Floatmu{szE, szf}, Integer}} where {szE, szf}" href="#Base.Math.ldexp-Union{Tuple{szf}, Tuple{szE}, Tuple{Floatmu{szE, szf}, Integer}} where {szE, szf}"><code>Base.Math.ldexp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ldexp(x::Floatmu{szE,szf}, n::Integer) where {szE, szf}</code></pre><p>Return <span>$x \times 2^n$</span>.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>This is a quick-and-dirty implementation.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ldexp(Floatmu{5,3}(2.5),3)
20.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goualard-f/MicroFloatingPoints.jl/blob/458829d22193a414d0ba7bee53b06b7185905eb8/src/Floatmu.jl#L298-L311">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.eps-Union{Tuple{Type{Floatmu{szE, szf}}}, Tuple{szf}, Tuple{szE}} where {szE, szf}" href="#Base.eps-Union{Tuple{Type{Floatmu{szE, szf}}}, Tuple{szf}, Tuple{szE}} where {szE, szf}"><code>Base.eps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eps(::Type{Floatmu{szE,szf}})  where {szE,szf}</code></pre><p>Return the <em>epsilon</em> of the type <code>Floatmu{szE,szf}</code>, which is the  difference between 1.0 and the next float.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; eps(Floatmu{2, 2})
0.25

julia&gt; eps(Floatmu{3, 5})
0.0312

julia&gt; eps(Floatmu{8, 23})==eps(Float32)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goualard-f/MicroFloatingPoints.jl/blob/458829d22193a414d0ba7bee53b06b7185905eb8/src/Floatmu.jl#L317-L334">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroFloatingPoints.λ-Union{Tuple{Type{Floatmu{szE, szf}}}, Tuple{szf}, Tuple{szE}} where {szE, szf}" href="#MicroFloatingPoints.λ-Union{Tuple{Type{Floatmu{szE, szf}}}, Tuple{szf}, Tuple{szE}} where {szE, szf}"><code>MicroFloatingPoints.λ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">λ(::Type{Floatmu{szE,szf}})  where {szE,szf}</code></pre><p>Return λ, the smallest positive <em>normal</em> number of the type <code>Floatmu{szE,szf}</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; λ(Floatmu{2, 2})
1.0

julia&gt; λ(Floatmu{8, 23})==floatmin(Float32)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goualard-f/MicroFloatingPoints.jl/blob/458829d22193a414d0ba7bee53b06b7185905eb8/src/Floatmu.jl#L343-L356">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroFloatingPoints.μ-Union{Tuple{Type{Floatmu{szE, szf}}}, Tuple{szf}, Tuple{szE}} where {szE, szf}" href="#MicroFloatingPoints.μ-Union{Tuple{Type{Floatmu{szE, szf}}}, Tuple{szf}, Tuple{szE}} where {szE, szf}"><code>MicroFloatingPoints.μ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">μ(::Type{Floatmu{szE,szf}})  where {szE,szf}</code></pre><p>Return μ, the smallest positive subnormal number of type <code>Floatmu{szE,szf}</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; μ(Floatmu{2, 2})
0.25</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goualard-f/MicroFloatingPoints.jl/blob/458829d22193a414d0ba7bee53b06b7185905eb8/src/Floatmu.jl#L360-L370">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.sign-Union{Tuple{Floatmu{szE, szf}}, Tuple{szf}, Tuple{szE}} where {szE, szf}" href="#Base.sign-Union{Tuple{Floatmu{szE, szf}}, Tuple{szf}, Tuple{szE}} where {szE, szf}"><code>Base.sign</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sign(x::Floatmu{szE,szf}) where {szE, szf}</code></pre><p>Return <code>x</code> if <code>x</code> is zero, 1.0 if <code>x</code> is strictly positive and -1.0 if <code>x</code> is strictly negative. Return <code>NaN</code> if x is a <em>Not a Number</em>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sign(Floatmu{2, 3}(-1.6))
-1.0

julia&gt; sign(Floatmu{2, 3}(1.6))
1.0

julia&gt; sign(Floatmu{2, 3}(NaN))
NaNμ{2, 3}

julia&gt; sign(Floatmu{2, 3}(-0.0))
-0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goualard-f/MicroFloatingPoints.jl/blob/458829d22193a414d0ba7bee53b06b7185905eb8/src/Floatmu.jl#L377-L398">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.floatmax-Union{Tuple{Type{Floatmu{szE, szf}}}, Tuple{szf}, Tuple{szE}} where {szE, szf}" href="#Base.floatmax-Union{Tuple{Type{Floatmu{szE, szf}}}, Tuple{szf}, Tuple{szE}} where {szE, szf}"><code>Base.floatmax</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">floatmax(::Type{Floatmu{szE,szf}})  where {szE,szf}</code></pre><p>Return the largest positive <em>normal</em> number of the type <code>Floatmu{szE,szf}</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; floatmax(Floatmu{2, 2})
3.5

julia&gt; floatmax(Floatmu{8, 23})==floatmax(Float32)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goualard-f/MicroFloatingPoints.jl/blob/458829d22193a414d0ba7bee53b06b7185905eb8/src/Floatmu.jl#L568-L581">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.floatmin-Union{Tuple{Type{Floatmu{szE, szf}}}, Tuple{szf}, Tuple{szE}} where {szE, szf}" href="#Base.floatmin-Union{Tuple{Type{Floatmu{szE, szf}}}, Tuple{szf}, Tuple{szE}} where {szE, szf}"><code>Base.floatmin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">floatmin(::Type{Floatmu{szE,szf}})  where {szE,szf}</code></pre><p>Return λ, the smallest positive <em>normal</em> number of the type <code>Floatmu{szE,szf}</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; floatmin(Floatmu{2, 2})
1.0

julia&gt; floatmin(Floatmu{8, 23})==floatmin(Float32)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goualard-f/MicroFloatingPoints.jl/blob/458829d22193a414d0ba7bee53b06b7185905eb8/src/Floatmu.jl#L591-L604">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.typemin-Union{Tuple{Type{Floatmu{szE, szf}}}, Tuple{szf}, Tuple{szE}} where {szE, szf}" href="#Base.typemin-Union{Tuple{Type{Floatmu{szE, szf}}}, Tuple{szf}, Tuple{szE}} where {szE, szf}"><code>Base.typemin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">typemin(::Type{Floatmu{szE,szf}})  where {szE,szf}</code></pre><p>Return the negative infinite of the type <code>Floatmu{szE,szf}</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; typemin(Floatmu{3, 5})
-Infμ{3, 5}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goualard-f/MicroFloatingPoints.jl/blob/458829d22193a414d0ba7bee53b06b7185905eb8/src/Floatmu.jl#L610-L620">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.typemax-Union{Tuple{Type{Floatmu{szE, szf}}}, Tuple{szf}, Tuple{szE}} where {szE, szf}" href="#Base.typemax-Union{Tuple{Type{Floatmu{szE, szf}}}, Tuple{szf}, Tuple{szE}} where {szE, szf}"><code>Base.typemax</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">typemax(::Type{Floatmu{szE,szf}})  where {szE,szf}</code></pre><p>Return the positive infinite of the type <code>Floatmu{szE,szf}</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; typemax(Floatmu{3, 5})
Infμ{3, 5}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goualard-f/MicroFloatingPoints.jl/blob/458829d22193a414d0ba7bee53b06b7185905eb8/src/Floatmu.jl#L625-L635">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.maxintfloat-Union{Tuple{Type{Floatmu{szE, szf}}}, Tuple{szf}, Tuple{szE}} where {szE, szf}" href="#Base.maxintfloat-Union{Tuple{Type{Floatmu{szE, szf}}}, Tuple{szf}, Tuple{szE}} where {szE, szf}"><code>Base.maxintfloat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">maxintfloat(::Type{Floatmu{szE,szf}})  where {szE,szf}</code></pre><p>Return the smallest positive integer <span>$n$</span> such that <span>$n+1$</span> is not representable in the type <code>Floatmu{szE,szf}</code>. The number <span>$n$</span> is returned as a  <code>Floatmu{szE,szf}</code>. </p><p>The function returns an infinite value if all integers are representable in the domain of normal values.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; maxintfloat(Floatmu{3,2})
8.0

julia&gt; maxintfloat(Floatmu{2,2})
Infμ{2, 2}

julia&gt; maxintfloat(Floatmu{8,23})==maxintfloat(Float32)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goualard-f/MicroFloatingPoints.jl/blob/458829d22193a414d0ba7bee53b06b7185905eb8/src/Floatmu.jl#L641-L663">source</a></section></article><p>Lastly, some methods test properties on the different parts of a <code>Floatmu</code>:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroFloatingPoints.fractional_even-Union{Tuple{Floatmu{szE, szf}}, Tuple{szf}, Tuple{szE}} where {szE, szf}" href="#MicroFloatingPoints.fractional_even-Union{Tuple{Floatmu{szE, szf}}, Tuple{szf}, Tuple{szE}} where {szE, szf}"><code>MicroFloatingPoints.fractional_even</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fractional_even(x::Floatmu{szE,szf}) where {szE,szf}</code></pre><p>Return <code>true</code> if the fractional part of <code>x</code> has a zero as the rightmost bit.</p><p>BEWARE: the function does not check whether <code>x</code> is an NaN or an infinite value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goualard-f/MicroFloatingPoints.jl/blob/458829d22193a414d0ba7bee53b06b7185905eb8/src/Floatmu.jl#L225-L231">source</a></section></article><h3 id="Tests"><a class="docs-heading-anchor" href="#Tests">Tests</a><a id="Tests-1"></a><a class="docs-heading-anchor-permalink" href="#Tests" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.signbit-Union{Tuple{Floatmu{szE, szf}}, Tuple{szf}, Tuple{szE}} where {szE, szf}" href="#Base.signbit-Union{Tuple{Floatmu{szE, szf}}, Tuple{szf}, Tuple{szE}} where {szE, szf}"><code>Base.signbit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">signbit(x::Floatmu{szE,szf}) where {szE, szf}</code></pre><p>Return <code>true</code> if <code>x</code> is signed and <code>false</code> otherwise. The result for a NaN may vary, depending on the value of its sign bit.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; signbit(Floatmu{2, 3}(1.5))
false
julia&gt; signbit(Floatmu{2, 3}(-1.5))
true</code></pre><p>The function differentiates between <span>$-0.0$</span> and <span>$+0.0$</span> even though both values test equal.</p><pre><code class="language-julia-repl hljs">julia&gt; signbit(Floatmu{2, 3}(-0.0))
true

julia&gt; signbit(Floatmu{2, 3}(0.0))
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goualard-f/MicroFloatingPoints.jl/blob/458829d22193a414d0ba7bee53b06b7185905eb8/src/Floatmu.jl#L412-L437">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.isnan-Union{Tuple{Floatmu{szE, szf}}, Tuple{szf}, Tuple{szE}} where {szE, szf}" href="#Base.isnan-Union{Tuple{Floatmu{szE, szf}}, Tuple{szf}, Tuple{szE}} where {szE, szf}"><code>Base.isnan</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isnan(x::Floatmu{szE,szf}) where {szE,szf}</code></pre><p>Return <code>true</code> if <code>x</code> is a <em>Not an Number</em> and <code>false</code> otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; isnan(Floatmu{2, 3}(1.5))
false

julia&gt; isnan(Floatmu{2, 3}(NaN))
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goualard-f/MicroFloatingPoints.jl/blob/458829d22193a414d0ba7bee53b06b7185905eb8/src/Floatmu.jl#L443-L457">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.isinf-Union{Tuple{Floatmu{szE, szf}}, Tuple{szf}, Tuple{szE}} where {szE, szf}" href="#Base.isinf-Union{Tuple{Floatmu{szE, szf}}, Tuple{szf}, Tuple{szE}} where {szE, szf}"><code>Base.isinf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isinf(x::Floatmu{szE,szf}) where {szE,szf}</code></pre><p>Return <code>true</code> if <code>x</code> is an infinity and <code>false</code> otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; isinf(Floatmu{2, 2}(1.5))
false

julia&gt; isinf(Floatmu{2, 2}(-Inf))
true

julia&gt; isinf(Floatmu{2, 2}(9.8))
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goualard-f/MicroFloatingPoints.jl/blob/458829d22193a414d0ba7bee53b06b7185905eb8/src/Floatmu.jl#L465-L481">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.isfinite-Union{Tuple{Floatmu{szE, szf}}, Tuple{szf}, Tuple{szE}} where {szE, szf}" href="#Base.isfinite-Union{Tuple{Floatmu{szE, szf}}, Tuple{szf}, Tuple{szE}} where {szE, szf}"><code>Base.isfinite</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isfinite(x::Floatmu{szE,szf}) where {szE,szf}</code></pre><p>Return <code>true</code> if <code>x</code> is finite and <code>false</code> otherwise. An NaN is not finite.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; isfinite(Floatmu{2, 2}(1.5))
true

julia&gt; isfinite(Floatmu{2, 2}(3.8))
false

julia&gt; isfinite(Floatmu{2, 2}(NaN))
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goualard-f/MicroFloatingPoints.jl/blob/458829d22193a414d0ba7bee53b06b7185905eb8/src/Floatmu.jl#L489-L505">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.issubnormal-Union{Tuple{Floatmu{szE, szf}}, Tuple{szf}, Tuple{szE}} where {szE, szf}" href="#Base.issubnormal-Union{Tuple{Floatmu{szE, szf}}, Tuple{szf}, Tuple{szE}} where {szE, szf}"><code>Base.issubnormal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">issubnormal(x::Floatmu{szE,szf}) where {szE,szf}</code></pre><p>Return <code>true</code> if <code>x</code> is a <a href="https://en.wikipedia.org/wiki/Denormal_number">subnormal number</a> and <code>false</code> otherwise. According to the definition, ±0.0 is not a subnormal number.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; issubnormal(Floatmu{2, 2}(1.0))
false

julia&gt; issubnormal(Floatmu{2, 2}(0.25))
true

julia&gt; issubnormal(Floatmu{2, 2}(0.0))
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goualard-f/MicroFloatingPoints.jl/blob/458829d22193a414d0ba7bee53b06b7185905eb8/src/Floatmu.jl#L511-L527">source</a></section></article><h3 id="Conversions"><a class="docs-heading-anchor" href="#Conversions">Conversions</a><a id="Conversions-1"></a><a class="docs-heading-anchor-permalink" href="#Conversions" title="Permalink"></a></h3><p>A <code>Floatmu</code> may be converted from and to any of the standard floating-point type (<code>Float16</code>, <code>Float32</code>, <code>Float64</code>).</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.convert" href="#Base.convert"><code>Base.convert</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">convert(::Type{Float64}, x::Floatmu{szE,szf}) where {szE, szf}
convert(::Type{Float32}, x::Floatmu{szE,szf}) where {szE, szf}
convert(::Type{Float16}, x::Floatmu{szE,szf}) where {szE, szf}
convert(::Type{Floatmu{szE,szf} where {szE,szf}}, x::Float64)
convert(::Type{Floatmu{szE,szf} where {szE,szf}}, x::Float32)
convert(::Type{Floatmu{szE,szf} where {szE,szf}}, x::Float16)</code></pre><p>Convert a <code>Floatmu</code> to a double, single or half precision float, or vice-versa. For the double precision,  the conversion never introduces errors since <code>Float64</code> objects have at least twice the precision  of the fractional part of a <code>Floatmu</code> object.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; convert(Float64,Floatmu{8, 23}(0.1))
0.10000000149011612

julia&gt; convert(Float32,Floatmu{8, 23}(0.1)) == 0.1f0
true

julia&gt; convert(Float32,Floatmu{5, 10}(0.1)) == Float16(0.1)
true

julia&gt; convert(Floatmu{2, 4},0.1)
0.125

julia&gt; convert(Floatmu{2, 4},0.1f0)
0.125

julia&gt; convert(Floatmu{2, 4},Float16(0.1))
0.125

julia&gt; Floatmu{5, 10}(0.1)==Float16(0.1)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goualard-f/MicroFloatingPoints.jl/blob/458829d22193a414d0ba7bee53b06b7185905eb8/src/Floatmu.jl#L796-L832">source</a></section></article><p>A <code>Floatmu</code> may also be created from a string:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.parse-Union{Tuple{szf}, Tuple{szE}, Tuple{Type{Floatmu{szE, szf}}, AbstractString}} where {szE, szf}" href="#Base.parse-Union{Tuple{szf}, Tuple{szE}, Tuple{Type{Floatmu{szE, szf}}, AbstractString}} where {szE, szf}"><code>Base.parse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parse(::Type{Floatmu{szE,szf}}, str::AbstractString) where {szE, szf}</code></pre><p>Parse the string <code>str</code> representing a floating-point number and convert it  to a <code>Floatmu{szE,szf}</code> object.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; parse(Floatmu{5, 7},&quot;0.1&quot;)
0.1

julia&gt; parse(Floatmu{5, 7},&quot;1.0e10&quot;)
Infμ{5, 7}</code></pre><p>The string is first converted to a <code>Float64</code> and then rounded to the precision of  the <code>Floatmu</code> object. If the string cannot be converted to a <code>Float64</code>, the <code>ArgumentError</code> exception is thrown.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; parse(Floatmu{5, 7},&quot;0.1a&quot;)
ERROR: ArgumentError: cannot parse &quot;0.1a&quot; as a Floatmu{5, 7}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goualard-f/MicroFloatingPoints.jl/blob/458829d22193a414d0ba7bee53b06b7185905eb8/src/Floatmu.jl#L903-L929">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.tryparse-Union{Tuple{szf}, Tuple{szE}, Tuple{Type{Floatmu{szE, szf}}, AbstractString}} where {szE, szf}" href="#Base.tryparse-Union{Tuple{szf}, Tuple{szE}, Tuple{Type{Floatmu{szE, szf}}, AbstractString}} where {szE, szf}"><code>Base.tryparse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tryparse(::Type{Floatmu{szE,szf}}, str::AbstractString) where {szE, szf}</code></pre><p>Parse the string <code>str</code> representing a floating-point number and convert it  to a <code>Floatmu{szE,szf}</code> object.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; tryparse(Floatmu{5, 7},&quot;0.1&quot;)
0.1

julia&gt; tryparse(Floatmu{5, 7},&quot;1.0e10&quot;)
Infμ{5, 7}</code></pre><p>The string is first converted to a <code>Float64</code> and then rounded to the precision of  the <code>Floatmu</code> object. Contrary to <code>parse</code>, if the string cannot be converted to a <code>Float64</code>, the value <code>nothing</code> is returned.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; tryparse(Floatmu{5, 7},&quot;0.1a&quot;) == nothing
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goualard-f/MicroFloatingPoints.jl/blob/458829d22193a414d0ba7bee53b06b7185905eb8/src/Floatmu.jl#L943-L970">source</a></section></article><h3 id="Display"><a class="docs-heading-anchor" href="#Display">Display</a><a id="Display-1"></a><a class="docs-heading-anchor-permalink" href="#Display" title="Permalink"></a></h3><p>Contrary to a <code>Float16</code> or a <code>Float32</code>, which are displayed by default with an indication of their type, a <code>Floatmu</code> is displayed as a number alone with no indication of its type (much like a <code>Float64</code>).</p><pre><code class="language-julia-repl hljs">julia&gt; Floatmu{2,2}(0.25)
0.25</code></pre><p>It is also possible to display the internal representation of a <code>Floatmu{szE,szf}</code> as an <span>$1+\text{szE}+\text{szf}$</span> bit string:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.bitstring-Union{Tuple{Floatmu{szE, szf}}, Tuple{szf}, Tuple{szE}} where {szE, szf}" href="#Base.bitstring-Union{Tuple{Floatmu{szE, szf}}, Tuple{szf}, Tuple{szE}} where {szE, szf}"><code>Base.bitstring</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bitstring(x::Floatmu{szE,szf}) where {szE,szf}</code></pre><p>Return the string of bits representing internally the value <code>x</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; bitstring(Floatmu{2, 2}(1.5))
&quot;00110&quot;

julia&gt; bitstring(Floatmu{2, 2}(0.5))
&quot;00010&quot;

julia&gt; bitstring(Floatmu{8, 23}(0.1))==bitstring(0.1f0)
true

julia&gt; bitstring(Floatmu{8, 23}(Inf)) == bitstring(Inf32)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goualard-f/MicroFloatingPoints.jl/blob/458829d22193a414d0ba7bee53b06b7185905eb8/src/Floatmu.jl#L1026-L1045">source</a></section></article><h3 id="Iterating-through-floats"><a class="docs-heading-anchor" href="#Iterating-through-floats">Iterating through floats</a><a id="Iterating-through-floats-1"></a><a class="docs-heading-anchor-permalink" href="#Iterating-through-floats" title="Permalink"></a></h3><p>As for the standard floating-point types, it is possible to go from one <code>Floatmu</code> to the next using <code>nextfloat</code> and <code>prevfloat</code>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.prevfloat-Union{Tuple{Floatmu{szE, szf}}, Tuple{szf}, Tuple{szE}, Tuple{Floatmu{szE, szf}, UInt32}} where {szE, szf}" href="#Base.prevfloat-Union{Tuple{Floatmu{szE, szf}}, Tuple{szf}, Tuple{szE}, Tuple{Floatmu{szE, szf}, UInt32}} where {szE, szf}"><code>Base.prevfloat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prevfloat(x::Floatmu{szE,szf}, n::UInt32 = 1) where {szE,szf}</code></pre><p>Return the <code>Floatmu{szE,szf}</code> float that is <code>n</code> floats before <code>x</code> in the natural order of floats.  Return <code>NaNμ{szE,szf}</code> if <code>x</code> is <em>Not a Number</em>. Return <code>-Infμ{szE,szf}</code> if there are less than <code>n</code> finite floats before <code>x</code> on the real line.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; prevfloat(Floatmu{2, 2}(1.0),2)
0.5

julia&gt; prevfloat(Floatmu{2, 2}(-0.0))
-0.25

julia&gt; prevfloat(Floatmu{2, 2}(Inf))
3.5

julia&gt; prevfloat(Floatmu{2, 2}(0.25))
0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goualard-f/MicroFloatingPoints.jl/blob/458829d22193a414d0ba7bee53b06b7185905eb8/src/Floatmu.jl#L1052-L1074">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.nextfloat-Union{Tuple{Floatmu{szE, szf}}, Tuple{szf}, Tuple{szE}, Tuple{Floatmu{szE, szf}, UInt32}} where {szE, szf}" href="#Base.nextfloat-Union{Tuple{Floatmu{szE, szf}}, Tuple{szf}, Tuple{szE}, Tuple{Floatmu{szE, szf}, UInt32}} where {szE, szf}"><code>Base.nextfloat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nextfloat(x::Floatmu{szE,szf}, n::UInt32 = 1) where {szE,szf}</code></pre><p>Return the <code>Floatmu{szE,szf}</code> float that is <code>n</code> floats after <code>x</code> in the natural order of floats.  Return <code>NaNμ{szE,szf}</code> if <code>x</code> is <em>Not a Number</em>. Return <code>Infμ{szE,szf}</code> if there are less than <code>n</code> finite floats after <code>x</code> on the real line.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; nextfloat(Floatmu{2, 2}(3.5))
Infμ{2, 2}

julia&gt; nextfloat(Floatmu{2, 2}(0.0),3)
0.75

julia&gt; nextfloat(Floatmu{2, 2}(-Inf))
-3.5

julia&gt; nextfloat(Floatmu{2, 2}(-0.25))
-0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goualard-f/MicroFloatingPoints.jl/blob/458829d22193a414d0ba7bee53b06b7185905eb8/src/Floatmu.jl#L1086-L1107">source</a></section></article><p>A <code>FloatmuIterator</code> allows to iterate on a range of <code>Floatmu</code> in a more systematic way:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroFloatingPoints.FloatmuIterator" href="#MicroFloatingPoints.FloatmuIterator"><code>MicroFloatingPoints.FloatmuIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FloatmuIterator(start::Floatmu{szE,szf},stop::Floatmu{szE,szf},
                step::Floatmu{szE,szf}) where {szE,szf}
FloatmuIterator(start::Floatmu{szE,szf},stop::Floatmu{szE,szf},
                step::Float64) where {szE,szf}
FloatmuIterator(start::Floatmu{szE,szf},stop::Floatmu{szE,szf},
                step::Int = 1) where {szE,szf}
FloatmuIterator(::Type{Floatmu{szE,szf}},start::Float64,stop::Float64,
                step::Int = 1) where {szE,szf}
FloatmuIterator(::Type{Floatmu{szE,szf}},start::Float64,stop::Float64,
                step::Float64) where {szE,szf}</code></pre><p>Iterator to generate all <code>Floatmu{szE,szf}</code> in the domain <code>[start,stop]</code>. The iterator can be initialized with two <code>Floatmu{szE,szf}</code> or with two <code>Float64</code>. </p><p>One may iterate from one float to the next (the default) or choose some step.  The step may be a number of floats or an amount to add.</p><p>An ArgumentError is raised if the bounds are NaNs, if the step chosen is zero (or rounds to zero when converted to a <code>Floatmu{szE,szf}</code>), or if the step is a value smaller than the largest distance between two consecutive floats in <code>[last, stop]</code> (use <a href="manual.html#MicroFloatingPoints.eligible_step"><code>eligible_step</code></a> to know the smallest value allowed).</p><p>When the step is an amount to add, the bounds cannot be infinities. </p><p>When the step is a number of floats, infinities are allowed for the bounds and are always part of the resulting range:</p><pre><code class="language-julia-repl hljs">julia&gt; collect(FloatmuIterator(Floatmu{2,2},-Inf,Inf,5))
6-element Vector{Floatmu{2, 2}}:
 -Infμ{2, 2}
  -1.75
  -0.5
   0.75
   2.0
  Infμ{2, 2}</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L=[x for x = FloatmuIterator(Floatmu{2, 2}(0.0), Floatmu{2, 2}(1.0))]
5-element Vector{Floatmu{2, 2}}:
 0.0
 0.25
 0.5
 0.75
 1.0
julia&gt; L2=[x for x = FloatmuIterator(Floatmu{2, 2}, 0.0, 1.0, 2)]
3-element Vector{Floatmu{2, 2}}:
 0.0
 0.5
 1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goualard-f/MicroFloatingPoints.jl/blob/458829d22193a414d0ba7bee53b06b7185905eb8/src/Floatmu.jl#L1297-L1351">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Effect of rounding on iterations</header><div class="admonition-body"><p>Keep in mind that the bounds of the iterator may need rounding when converted to a <code>Floatmu</code>, so that the number of iterations may not be the one expected.  Additionnally, the step chosen may induce more rounding at each iteration.</p><h4>Example</h4><pre><code class="language-julia hljs">julia&gt; [x for x in FloatmuIterator(Floatmu{2,2},-1.2,-0.2,0.3)]
4-element Vector{Floatmu{2,2}}:
-1.25
-1.0
-0.75
-0.5

julia&gt; FloatmuIterator(Floatmu{2,2},-1.2,-0.2,0.3)
FloatmuIterator{2,2}(-1.25, -0.25, 0.25)</code></pre></div></div><p>It is possible to know in advance the number of floats in the resulting range with the <a href="https://docs.julialang.org/en/v1/base/collections/#Base.length"><code>length</code></a> function.	</p><p>As stated in the documentation for <code>FloatmuIterator</code> above, one cannot use a floating-point step smaller than the largest gap in the domain we iterate through. The function <code>eligible_step</code> gives the smallest value allowed when given two bounds.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroFloatingPoints.eligible_step" href="#MicroFloatingPoints.eligible_step"><code>MicroFloatingPoints.eligible_step</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eligible_step(start::Floatmu{szE,szf}, stop::Floatmu{szE,szf}) where {szE,szf}
eligible_step(::Type{Floatmu{szE,szf}}, start::Float64, stop::Float64) where {szE,szf}</code></pre><p>Return the smallest <code>Floatmu{szE,szf}</code> eligible step allowed to iterate through the domain <code>[start,stop]</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; eligible_step(Floatmu{2,2}(-0.5),Floatmu{2,2}(2.5))
0.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goualard-f/MicroFloatingPoints.jl/blob/458829d22193a414d0ba7bee53b06b7185905eb8/src/Floatmu.jl#L1248-L1261">source</a></section></article><h3 id="Rounding"><a class="docs-heading-anchor" href="#Rounding">Rounding</a><a id="Rounding-1"></a><a class="docs-heading-anchor-permalink" href="#Rounding" title="Permalink"></a></h3><p>We have seen in section <a href="manual.html#Creating-a-Floatmu-float">Creating a <code>Floatmu</code> float</a> that each <code>Floatmu</code> retains the information whether the value it was created from required rounding or not.</p><p>In addition to that mechanism, the <code>MicroFloatingPoints</code> module keeps a global variable that is set to <code>true</code> every time a <code>Floatmu</code> is created and rounding takes place. That variable is <em>sticky</em> (once true, it stays true until reset explictly to <code>false</code>). It can be checked with the <code>inexact()</code> method and reset with the <code>reset_inexact()</code> method.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroFloatingPoints.inexact-Tuple{}" href="#MicroFloatingPoints.inexact-Tuple{}"><code>MicroFloatingPoints.inexact</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inexact()</code></pre><p>Return the value of the global inexact flag.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goualard-f/MicroFloatingPoints.jl/blob/458829d22193a414d0ba7bee53b06b7185905eb8/src/Floatmu.jl#L1240-L1244">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroFloatingPoints.reset_inexact-Tuple{}" href="#MicroFloatingPoints.reset_inexact-Tuple{}"><code>MicroFloatingPoints.reset_inexact</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reset_inexact()</code></pre><p>Reset the global inexact flag to <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goualard-f/MicroFloatingPoints.jl/blob/458829d22193a414d0ba7bee53b06b7185905eb8/src/Floatmu.jl#L1229-L1234">source</a></section></article><p>With these methods, one can check whether some computation needed rounding at some point:</p><pre><code class="language-julia-repl hljs">julia&gt; reset_inexact()

julia&gt; inexact()
false

julia&gt; Floatmu{2,2}(2.0)+Floatmu{2,2}(0.25)
2.0

julia&gt; inexact()
true

julia&gt; reset_inexact()

julia&gt; Floatmu{2,2}(2.0)+Floatmu{2,2}(0.25)+Floatmu{2,2}(0.25)
2.0

julia&gt; inexact()
true</code></pre><p>Note that, in the first example, the result of the computation needed rounding, while in the second example, the output is representable but one of the intermediary computation needed rounding. </p><h2 id="The-MicroFloatingPoints.MFPUtils-module"><a class="docs-heading-anchor" href="#The-MicroFloatingPoints.MFPUtils-module">The <code>MicroFloatingPoints.MFPUtils</code> module</a><a id="The-MicroFloatingPoints.MFPUtils-module-1"></a><a class="docs-heading-anchor-permalink" href="#The-MicroFloatingPoints.MFPUtils-module" title="Permalink"></a></h2><p>The <code>MicroFloatingPoints.MFPUtils</code> module offers some utiliy functions to be used either by other modules of the <code>MicroFloatingPoints</code> package or directly by the end user.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroFloatingPoints.MFPUtils.vertical_popcount-Union{Tuple{Array{Floatmu{szE, szf}, 1}}, Tuple{szf}, Tuple{szE}} where {szE, szf}" href="#MicroFloatingPoints.MFPUtils.vertical_popcount-Union{Tuple{Array{Floatmu{szE, szf}, 1}}, Tuple{szf}, Tuple{szE}} where {szE, szf}"><code>MicroFloatingPoints.MFPUtils.vertical_popcount</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vertical_popcount(T::Vector{Floatmu{szE,szf}}) where {szE,szf}</code></pre><p>Return a vector <code>R</code> of size <code>1+szE+szf</code> where <code>R[i]</code> is the number of times the <code>i</code>-th bit of the values in <code>T</code> was equal to <code>1</code>. </p><p>For this function, the rightmost bit of the binary representation of a <code>Floatmu</code> has index <code>1</code> and not <code>0</code> as usual.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; join(string.(reverse(vertical_popcount(Floatmu{2,2}[1.5])))) == bitstring(Floatmu{2,2}(1.5))
true</code></pre><p>Note that, in the preceding example, we have to revert the array obtained from <code>vertical_popcount</code> because the number of times bit <code>i</code> is <code>1</code> is saved at position <code>i</code>. As a consequence, the value for the rightmost bit of a <code>Floatmu</code> appears at the leftmost position of the counting array.</p><pre><code class="language-julia-repl hljs">julia&gt; println(vertical_popcount(Floatmu{2,2}[0.25,1.5,3.0]))
[1, 2, 1, 1, 0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goualard-f/MicroFloatingPoints.jl/blob/458829d22193a414d0ba7bee53b06b7185905eb8/src/MFPUtils.jl#L27-L47">source</a></section></article><h2 id="The-MicroFloatingPoints.MFPRandom-module"><a class="docs-heading-anchor" href="#The-MicroFloatingPoints.MFPRandom-module">The <code>MicroFloatingPoints.MFPRandom</code> module</a><a id="The-MicroFloatingPoints.MFPRandom-module-1"></a><a class="docs-heading-anchor-permalink" href="#The-MicroFloatingPoints.MFPRandom-module" title="Permalink"></a></h2><p>The <code>MicroFloatingPoints.MFPRandom</code> module overloads <a href="https://docs.julialang.org/en/v1/stdlib/Random/#Base.rand"><code>rand</code></a> to offer <code>Floatmu</code> floating-point numbers drawn at random in <span>$[0,1)$</span>. The method uses <code>Random.rand</code> under the hood. It is then affected in the same way by  <code>Random.seed!</code>.</p><pre><code class="language-repl hljs">julia&gt; Random.seed!(42);

julia&gt; rand(Floatmu{2,2})

julia&gt; rand(Floatmu{2,2})</code></pre><p>It is possible to draw <code>Floatmu</code> values at random in the same way as with other floating-point types:</p><pre><code class="language-repl hljs">julia&gt; rand(Floatmu{2,2},5)</code></pre><p>Using the <a href="https://juliastats.org/Distributions.jl/stable/"><code>Distributions</code></a> package, one can also draw <code>Floatmu</code> numbers with other distributions:</p><pre><code class="language-repl hljs">julia&gt; rand(Uniform(Floatmu{2,2}(-1.0),Floatmu{2,2}(1.0)))</code></pre><div class="admonition is-warning"><header class="admonition-header">Using custom distributions</header><div class="admonition-body"><p>One must be wary of very small <code>Floatmu</code> types when using other distributions than <span>$U[0,1)$</span> as the computation necessary to compute another distribution may  easily involve larger numbers than can be represented with the type. Consider, for example, the type <code>Floatmu{2,2}</code> whose largest positive finite value is <code>3.0</code>.  If we decide to draw numbers in the domain <span>$[-2,2)$</span>, we will call:</p><pre><code class="language-julia hljs">rand(Uniform(Floatmu{2,2}(-2.0),Floatmu{2,2}(2.0)))</code></pre><p>To translate the distribution from <span>$[0,1)$</span> to <span>$[-2,2)$</span>, the <code>Uniform</code> method will draw a value <span>$x$</span> in <span>$[0,1)$</span> and apply the formula <span>$a+(b-a)x$</span>, with <span>$a=-2$</span> and <span>$b=2$</span>. Unfortunately, <span>$b-a$</span> will then be  <span>$\text{Floatmu\{2,2\}}(2.0)-\text{Floatmu}\{2,2\}(-2.0)$</span>, which is rounded to  <code>Infμ{2,2}</code>. Consequently, we will always draw the same infinite value:</p><pre><code class="language-julia hljs">julia&gt; rand(Uniform(Floatmu{2,2}(-2.0),Floatmu{2,2}(2.0)))
Infμ{2, 2}

julia&gt; rand(Uniform(Floatmu{2,2}(-2.0),Floatmu{2,2}(2.0)))
Infμ{2, 2}
</code></pre></div></div><h2 id="The-MicroFloatingPoints.MFPPlot-module"><a class="docs-heading-anchor" href="#The-MicroFloatingPoints.MFPPlot-module">The <code>MicroFloatingPoints.MFPPlot</code> module</a><a id="The-MicroFloatingPoints.MFPPlot-module-1"></a><a class="docs-heading-anchor-permalink" href="#The-MicroFloatingPoints.MFPPlot-module" title="Permalink"></a></h2><p>The <code>MicroFloatingPoints.MFPPlot</code> module offers some methods to easily represent floating-point numbers.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroFloatingPoints.MFPPlot.real_line" href="#MicroFloatingPoints.MFPPlot.real_line"><code>MicroFloatingPoints.MFPPlot.real_line</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">real_line(start::Floatmu{szE,szf}, stop::Floatmu{szE,szf};
          ticks = true, 
          fpcolorsub = &quot;purple&quot;, fpcolornorm = &quot;blue&quot;) where {szE,szf}
real_line(::Type{Floatmu{szE,szf}};
          ticks = true, 
          fpcolorsub = &quot;purple&quot;, fpcolornorm = &quot;blue&quot;,
          fpcolorinf=&quot;orange&quot;) where {szE,szf}
real_line(T::Vector{Floatmu{szE,szf}};
               ticks = true, fpcolorsub = &quot;purple&quot;, fpcolornorm = &quot;blue&quot;,
               fpcolorinf=&quot;orange&quot;) where {szE,szf}</code></pre><p>Draw floats on the real line.</p><p>The first version draws the real line between <code>start</code> and <code>stop</code> and displays all floating-point numbers with <code>sze</code> bits exponent and <code>szf</code> bits fractional part. The second version draws all finite  floating-point for the format <code>Floatmu{szE,szf}</code> and adds the infinities where the next/previous  float would be with the format <code>Floatmu{szE+1,szf}</code>. The third version draws all floats in the  vector <code>T</code>.</p><p>In the first version, both parameters <code>start</code> and <code>stop</code> must be finite. An <code>ArgumentError</code> exception is raised otherwise. The same goes for all values in <code>T</code> for the third version.</p><p>All versions return the figure used for the plot.</p><p>The figure may be customized through the named parameters:</p><ul><li><code>ticks</code>: if <code>true</code>, draws a vertical line for each float and adds the value below. If   <code>false</code>, represent each float by a dot on the real line, without its value;</li><li><code>fpcolorsub</code>: color of the line or dot used to represent subnormals;</li><li><code>fpcolornorm</code>: color of the line or dot used to represent normal values;</li><li><code>fpcolorinf</code> [for the second version only]: color of the line or dot used to represent infinite values.</li></ul><p><strong>Examples of calls</strong></p><pre><code class="language- hljs">real_line(-floatmax(Floatmu{2,2}),floatmax(Floatmu{2,2}));
real_line(Floatmu{2,2});
real_line(Floatmu{2,2}[-3.5,0.25,1.5,2.0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goualard-f/MicroFloatingPoints.jl/blob/458829d22193a414d0ba7bee53b06b7185905eb8/src/MFPPlot.jl#L30-L69">source</a></section></article><h3 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h3><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; real_line(Floatmu{2,3}(-2.5),Floatmu{2,3}(1.0));</code><code class="nohighlight hljs ansi" style="display:block;"></code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><div style="text-align: center">
<img src="./realline_Floatmu23a.svg" alt="Floatmu{2,3} values in [-2.5, 1.0]" />
</div><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; real_line(Floatmu{2,3});</code><code class="nohighlight hljs ansi" style="display:block;"></code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><div style="text-align: center">
<img src="./realline_Floatmu23b.svg" alt="Floatmu{2,3} finite and infinite values" />
</div><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroFloatingPoints.MFPPlot.bits_histogram-Union{Tuple{Array{Floatmu{szE, szf}, 1}}, Tuple{szf}, Tuple{szE}} where {szE, szf}" href="#MicroFloatingPoints.MFPPlot.bits_histogram-Union{Tuple{Array{Floatmu{szE, szf}, 1}}, Tuple{szf}, Tuple{szE}} where {szE, szf}"><code>MicroFloatingPoints.MFPPlot.bits_histogram</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bits_histogram(T::Vector{Floatmu{szE,szf}};
               signcolor = &quot;magenta&quot;,
               expcolor = &quot;darkolivegreen&quot;,
               fraccolor = &quot;blue&quot;) where {szE,szf}</code></pre><p>Draw an histogram of the probability of each bit of the representation of a float to be <code>1</code> in the sample <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goualard-f/MicroFloatingPoints.jl/blob/458829d22193a414d0ba7bee53b06b7185905eb8/src/MFPPlot.jl#L165-L173">source</a></section></article><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; T=collect(FloatmuIterator(Floatmu{3,5},0.0,1.0,2.0^-6));</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; bits_histogram(T)</code><code class="nohighlight hljs ansi" style="display:block;"></code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><div style="text-align: center">
<img src="./bits_histogram.svg" alt="Floatmu{3,4} bits histogram in [0, 1]" />
</div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="guided-tour.html">« A Guided Tour</a><a class="docs-footer-nextpage" href="developer.html">Developer Documentation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Monday 1 July 2024 07:44">Monday 1 July 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
