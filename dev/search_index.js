var documenterSearchIndex = {"docs":
[{"location":"guided-tour.html","page":"A Guided Tour","title":"A Guided Tour","text":"DocTestSetup = quote\n    using MicroFloatingPoints\n\tusing MicroFloatingPoints.MFPPlot, MicroFloatingPoints.MFPRandom\nend\nCurrentModule = MicroFloatingPoints","category":"page"},{"location":"guided-tour.html#A-guided-tour","page":"A Guided Tour","title":"A guided tour","text":"","category":"section"},{"location":"guided-tour.html","page":"A Guided Tour","title":"A Guided Tour","text":"The MicroFloatingPoints package is organized into four modules:","category":"page"},{"location":"guided-tour.html","page":"A Guided Tour","title":"A Guided Tour","text":"MicroFloatingPoints: the main module containing the definition of the parameterized type Floatmu and the associated methods;\nMicroFloatingPoints.MFPUtils: a module providing miscellaneous utility functions for the Floatmu type;\nMicroFloatingPoints.MFPPlot: a module offering various graphical ways to display Floatmu floating-point numbers;\nMicroFloatingPoints.MFPRandom: the module overloading Random.rand to produce Floatmu random values.","category":"page"},{"location":"guided-tour.html","page":"A Guided Tour","title":"A Guided Tour","text":"After having correctly installed the package (see Installation), we start our tour by loading the MicroFloatingPoints module:","category":"page"},{"location":"guided-tour.html","page":"A Guided Tour","title":"A Guided Tour","text":"using PyPlot","category":"page"},{"location":"guided-tour.html","page":"A Guided Tour","title":"A Guided Tour","text":"using MicroFloatingPoints","category":"page"},{"location":"guided-tour.html","page":"A Guided Tour","title":"A Guided Tour","text":"We can now define a new floating-point type MuFP with 2 bits for the exponent (the first parameter)  and 2 bits for the fractional part (the second parameter):","category":"page"},{"location":"guided-tour.html","page":"A Guided Tour","title":"A Guided Tour","text":"MuFP = Floatmu{2,2}","category":"page"},{"location":"guided-tour.html","page":"A Guided Tour","title":"A Guided Tour","text":"Such a type is very limited, and a call to floatmax will give us the largest finite float representable:","category":"page"},{"location":"guided-tour.html","page":"A Guided Tour","title":"A Guided Tour","text":"floatmax(MuFP)","category":"page"},{"location":"guided-tour.html","page":"A Guided Tour","title":"A Guided Tour","text":"Conversely, we can obtain the smallest positive float in the MuFP format with the μ method:","category":"page"},{"location":"guided-tour.html","page":"A Guided Tour","title":"A Guided Tour","text":"μ(MuFP)","category":"page"},{"location":"guided-tour.html","page":"A Guided Tour","title":"A Guided Tour","text":"Note that this value is a subnormal number, which is different and smaller than the smallest normal float, obtained by calling floatmin:","category":"page"},{"location":"guided-tour.html","page":"A Guided Tour","title":"A Guided Tour","text":"floatmin(MuFP)","category":"page"},{"location":"guided-tour.html#Graphics-with-MicroFloatingPoints.MFPPlot","page":"A Guided Tour","title":"Graphics with MicroFloatingPoints.MFPPlot","text":"","category":"section"},{"location":"guided-tour.html","page":"A Guided Tour","title":"A Guided Tour","text":"To better assess what we can do with such a small type, let us display all finite representable values on the real line. The Plot module has just the right method:","category":"page"},{"location":"guided-tour.html","page":"A Guided Tour","title":"A Guided Tour","text":"using MicroFloatingPoints.MFPPlot\nreal_line(-floatmax(MuFP),floatmax(MuFP));\nsavefig(\"mufp_realline.svg\"); nothing # hide","category":"page"},{"location":"guided-tour.html","page":"A Guided Tour","title":"A Guided Tour","text":"<div style=\"text-align: center\">\n<img src=\"./mufp_realline.svg\" alt=\"Floatmu{2,2} representable finite values\" />\n</div>","category":"page"},{"location":"guided-tour.html","page":"A Guided Tour","title":"A Guided Tour","text":"Since the difference between any pair of MuFP is always greater or equal to μ(MuFP), it becomes apparent why the introduction of subnormal numbers (in purple in the picture above) ensures the property:","category":"page"},{"location":"guided-tour.html","page":"A Guided Tour","title":"A Guided Tour","text":"forall (ab)intextMuFPcolon b-a = 0 iff a=b","category":"page"},{"location":"guided-tour.html#Exhaustive-search-for-rounded-additions","page":"A Guided Tour","title":"Exhaustive search for rounded additions","text":"","category":"section"},{"location":"guided-tour.html","page":"A Guided Tour","title":"A Guided Tour","text":"The type MuFP is so small that we can easily perform exhaustive searches with it. For example, we can display graphically whether the sum of any two finite MuFP floats needs to be rounded or not, using the inexact() and reset_inexact() methods to, respectively, test whether the preceding computation needed rounding and to reset the global inexact flag:","category":"page"},{"location":"guided-tour.html","page":"A Guided Tour","title":"A Guided Tour","text":"using MicroFloatingPoints\nusing PyPlot\nMuFP = Floatmu{2,2}","category":"page"},{"location":"guided-tour.html","page":"A Guided Tour","title":"A Guided Tour","text":"plt.figure()\nplt.title(\"Exhaustive search for rounded sums in Floatmu{2,2}\")\nTotalIterator = FloatmuIterator(-floatmax(MuFP),floatmax(MuFP))\nN = length(TotalIterator)\nZ = zeros(Int,N,N)\nlet i = 1\n    for v1 in TotalIterator\n        j = 1\n        for v2 in TotalIterator\n            reset_inexact()\n            v1+v2\n            Z[i,j] = Int(inexact())\n            j += 1\n        end\n        i += 1\n    end\nend\nV = collect(TotalIterator)\nimshow(Z,origin=\"lower\", cmap=\"summer\")\nplt.yticks(0:(length(V)-1),[string(V[i]) for i in 1:length(V)])\nplt.xticks(0:(length(V)-1),[string(V[i]) for i in 1:length(V)],rotation=90);\nsavefig(\"exhaustive-rounding.svg\"); nothing #hide","category":"page"},{"location":"guided-tour.html","page":"A Guided Tour","title":"A Guided Tour","text":"Note the use of a FloatmuIterator to enumerate all floating-point numbers in a range.","category":"page"},{"location":"guided-tour.html","page":"A Guided Tour","title":"A Guided Tour","text":"We obtain the following matrix, where a green cell means that the sum of the values in row and column needs no rounding, while a yellow cell means that the result needs rounding to be represented by a Floatmu{2,2}.","category":"page"},{"location":"guided-tour.html","page":"A Guided Tour","title":"A Guided Tour","text":"<div style=\"text-align: center\">\n<img src=\"./exhaustive-rounding.svg\" alt=\"Exhautive search for sums of Floatmu{2,2} needing rounding\" />\n</div>","category":"page"},{"location":"guided-tour.html#Random-floats-with-MicroFloatingPoints.MFPRandom","page":"A Guided Tour","title":"Random floats with MicroFloatingPoints.MFPRandom","text":"","category":"section"},{"location":"guided-tour.html","page":"A Guided Tour","title":"A Guided Tour","text":"Let us now draw some BFloat16 floats uniformly at random in 01). We will use the MicroFloatingPoints.MFPRandom module to overload the rand method for the type Floatmu.","category":"page"},{"location":"guided-tour.html","page":"A Guided Tour","title":"A Guided Tour","text":"using DataStructures\nusing PyPlot\nusing MicroFloatingPoints\nusing MicroFloatingPoints.MFPRandom\n\nBFloat16 = Floatmu{8,7}\n\nndraws=1000000\nplt.figure()\nplt.title(\"Drawing $ndraws values at random in BFloat16[0,1)\")\nT = [rand(BFloat16) for i in 1:ndraws]\nTc = counter(T)\nnothing # hide","category":"page"},{"location":"guided-tour.html","page":"A Guided Tour","title":"A Guided Tour","text":"We can now display the number of times each float was drawn:","category":"page"},{"location":"guided-tour.html","page":"A Guided Tour","title":"A Guided Tour","text":"for x in Tc\n    (k,v) = x\n    plot([k,k],[0,v],marker=\".\",color=\"blue\",alpha=0.5)\nend\n(low,high) = extrema(collect(values(Tc)))\nplt.ylim(ymin=0.99*low,ymax=1.01*high)\nsavefig(\"randfreq-bfloat16.svg\"); nothing # hide","category":"page"},{"location":"guided-tour.html","page":"A Guided Tour","title":"A Guided Tour","text":"<div style=\"text-align: center\">\n<img src=\"./randfreq-bfloat16.svg\" alt=\"Drawing values at random in BFloat16\" />\n</div>","category":"page"},{"location":"guided-tour.html#Arithmetic-with-various-precisions","page":"A Guided Tour","title":"Arithmetic with various precisions","text":"","category":"section"},{"location":"guided-tour.html","page":"A Guided Tour","title":"A Guided Tour","text":"The BFloat16 and Float16 formats both represent floating-point numbers with 16 bits. The BFloat16 trades precision for a larger range. Let us compare the results obtained when summing the values of a vector with both types:","category":"page"},{"location":"guided-tour.html","page":"A Guided Tour","title":"A Guided Tour","text":"using MicroFloatingPoints\nusing Random\nusing Distributions\nRandom.seed!(42)","category":"page"},{"location":"guided-tour.html","page":"A Guided Tour","title":"A Guided Tour","text":"BFloat16 = Floatmu{8,7}\nMuFloat16 = Floatmu{5,10} \nT64 = [rand() for i in 1:1000]\nbfT16 = [BFloat16(x) for x in T64]\nFT16 = [MuFloat16(x) for x in T64]\nprintln(sum(T64))\nprintln(sum(bfT16))\nprintln(sum(FT16))","category":"page"},{"location":"guided-tour.html","page":"A Guided Tour","title":"A Guided Tour","text":"For small values in 01),  the effect of a smaller significand appears drastic. On the other hand, the small range of the type Float16 makes it useless for computation with medium to large numbers:","category":"page"},{"location":"guided-tour.html","page":"A Guided Tour","title":"A Guided Tour","text":"T64 = [rand(Uniform(min(floatmin(BFloat16),floatmin(MuFloat16)),\n            max(floatmax(BFloat16),floatmax(MuFloat16))/100)) for i in 1:100]\nbfT16 = [BFloat16(x) for x in T64]\nFT16 = [MuFloat16(x) for x in T64]\nprintln(sum(T64))\nprintln(sum(bfT16))\nprintln(sum(FT16))","category":"page"},{"location":"developer.html","page":"Developer Documentation","title":"Developer Documentation","text":"DocTestSetup = quote\n\tusing Random\n    using MicroFloatingPoints\n\tusing MicroFloatingPoints.MFPPlot, MicroFloatingPoints.MFPRandom\nend\nCurrentModule = MicroFloatingPoints","category":"page"},{"location":"developer.html#Developer-Documentation","page":"Developer Documentation","title":"Developer Documentation","text":"","category":"section"},{"location":"developer.html","page":"Developer Documentation","title":"Developer Documentation","text":"This part is intended for developers who intend to extend or maintain the package.","category":"page"},{"location":"developer.html","page":"Developer Documentation","title":"Developer Documentation","text":"warning: Work In Progress\nThis part is a work in progress and should be expanded in the next revisions.","category":"page"},{"location":"developer.html#Construction-of-a-Floatmu","page":"Developer Documentation","title":"Construction of a Floatmu","text":"","category":"section"},{"location":"developer.html","page":"Developer Documentation","title":"Developer Documentation","text":"The Floatmu type has two constructors that create a float directly from its integer representation.","category":"page"},{"location":"developer.html","page":"Developer Documentation","title":"Developer Documentation","text":"Floatmu{szE,szf}(x::UInt32, dummy) where {szE,szf}\nFloatmu{szE,szf}(x::Tuple{UInt32,Int64}, dummy) where {szE,szf}","category":"page"},{"location":"developer.html","page":"Developer Documentation","title":"Developer Documentation","text":"The first constructor uses x as the internal representation of the float, assuming no rounding occurred; the second constructor uses the UInt32 element of the tuple as the internal representation , while the Int64 element correspond to the sign of the error if some rounding took place to generate the float.","category":"page"},{"location":"developer.html","page":"Developer Documentation","title":"Developer Documentation","text":"For both constructors, dummy may be anything and serves only to avoid ambiguities when calling a constructor. It is customary to use nothing for this parameter and the code of the package always does.","category":"page"},{"location":"developer.html","page":"Developer Documentation","title":"Developer Documentation","text":"nb_fp_numbers(a::Floatmu{szE,szf}, b::Floatmu{szE,szf}) where {szE,szf}\nMicroFloatingPoints.inexact_flag\nMicroFloatingPoints.double_fields(x::Float64)\nMicroFloatingPoints.roundfrac(f,szf)\nMicroFloatingPoints.float64_to_uint32mu(x::Float64,szE,szf)","category":"page"},{"location":"developer.html#MicroFloatingPoints.nb_fp_numbers-Union{Tuple{szf}, Tuple{szE}, Tuple{Floatmu{szE, szf}, Floatmu{szE, szf}}} where {szE, szf}","page":"Developer Documentation","title":"MicroFloatingPoints.nb_fp_numbers","text":"nb_fp_numbers(a::Floatmu{szE,szf}, b::Floatmu{szE,szf}) where {szE,szf}\n\nReturn the number of floats in the interval ab. If a  b, throw an ArgumentError exception.\n\nExamples\n\njulia> nb_fp_numbers(Floatmu{2, 2}(-0.0),Floatmu{2, 2}(0.0))\n1\njulia> nb_fp_numbers(Floatmu{2, 2}(3.0),Floatmu{2, 2}(3.5))\n2\n\n\n\n\n\n","category":"method"},{"location":"developer.html#MicroFloatingPoints.inexact_flag","page":"Developer Documentation","title":"MicroFloatingPoints.inexact_flag","text":"inexact_flag\n\nFlag set to true if the latest computation led to some rounding. This is a sticky flag, which must be explictly reset.\n\nSee reset_inexact()\n\n\n\n\n\n","category":"constant"},{"location":"developer.html#MicroFloatingPoints.double_fields-Tuple{Float64}","page":"Developer Documentation","title":"MicroFloatingPoints.double_fields","text":"double_fields(x::Float64)\n\nReturn the sign, biased exponent, and fractional part of a Float64 number.\n\n\n\n\n\n","category":"method"},{"location":"developer.html#MicroFloatingPoints.roundfrac-Tuple{Any, Any}","page":"Developer Documentation","title":"MicroFloatingPoints.roundfrac","text":"roundfrac(f,szf)\n\nRound to nearest-even a 52 bits fractional part to szf bits  Return a triplet composed of the rounded fractional part, a correction to the exponent if a bit from the fractional part spilled into the integer part, and a rounding direction (by default: -1, by excess: 1, no rounding: 0) if some rounding had to take place. \n\n\n\n\n\n","category":"method"},{"location":"developer.html#MicroFloatingPoints.float64_to_uint32mu-Tuple{Float64, Any, Any}","page":"Developer Documentation","title":"MicroFloatingPoints.float64_to_uint32mu","text":"float64_to_uint32mu(x::Float64,szE,szf)\n\nRound x to the precision of a Floatmu{szE,szf} and  return a pair composed of the bits representation right-aligned in a UInt32 together with a rounding direction if rounding took place (by default: -1, by excess: 1, no rounding: 0).\n\n\n\n\n\n","category":"method"},{"location":"developer.html#Iterators","page":"Developer Documentation","title":"Iterators","text":"","category":"section"},{"location":"developer.html","page":"Developer Documentation","title":"Developer Documentation","text":"check_eligibility_step(start::Floatmu{szE,szf}, stop::Floatmu{szE,szf}, step::Floatmu{szE,szf}) where {szE,szf}","category":"page"},{"location":"developer.html#MicroFloatingPoints.check_eligibility_step-Union{Tuple{szf}, Tuple{szE}, Tuple{Floatmu{szE, szf}, Floatmu{szE, szf}, Floatmu{szE, szf}}} where {szE, szf}","page":"Developer Documentation","title":"MicroFloatingPoints.check_eligibility_step","text":"check_eligibility_step(start::Floatmu{szE,szf}, stop::Floatmu{szE,szf},\n                       step::Floatmu{szE,szf}) where {szE,szf}\n\nCheck whether the step step can be reliability used for the domain [start, stop]. Throw an ArgumentError exception in the negative.\n\n\n\n\n\n","category":"method"},{"location":"developer.html#The-MicroFloatingPoints.MFPRandom-module","page":"Developer Documentation","title":"The MicroFloatingPoints.MFPRandom module","text":"","category":"section"},{"location":"developer.html","page":"Developer Documentation","title":"Developer Documentation","text":"CurrentModule = MicroFloatingPoints.MFPRandom","category":"page"},{"location":"developer.html","page":"Developer Documentation","title":"Developer Documentation","text":"using Random","category":"page"},{"location":"developer.html","page":"Developer Documentation","title":"Developer Documentation","text":"MicroFloatingPoints.MFPRandom.irandint(rng::Random.AbstractRNG, n::Int64)","category":"page"},{"location":"developer.html#MicroFloatingPoints.MFPRandom.irandint-Tuple{AbstractRNG, Int64}","page":"Developer Documentation","title":"MicroFloatingPoints.MFPRandom.irandint","text":"irandint(rng::Random.AbstractRNG, n::Int64)\n\nDraw a n bits integer at random.\n\nFirst, compute a 64 bits integer, then discard the lowest (64-n) bits, which  are often the less random ones.\n\nThrow an ArgumentError exception if n is strictly greater than 64.\n\n\n\n\n\n","category":"method"},{"location":"developer.html#Examples","page":"Developer Documentation","title":"Examples","text":"","category":"section"},{"location":"developer.html","page":"Developer Documentation","title":"Developer Documentation","text":"julia> MicroFloatingPoints.MFPRandom.irandint(Random.MersenneTwister(42),23)","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"DocTestSetup = quote\n\tusing Distributions, Random\n    using MicroFloatingPoints\n\tusing MicroFloatingPoints.MFPPlot, MicroFloatingPoints.MFPRandom\n\tusing MicroFloatingPoints.MFPUtils\nend\nCurrentModule = MicroFloatingPoints","category":"page"},{"location":"manual.html#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual.html#The-MicroFloatingPoints-module","page":"Manual","title":"The MicroFloatingPoints module","text":"","category":"section"},{"location":"manual.html","page":"Manual","title":"Manual","text":"The central element of the MicroFloatingPoints package is the floating-point type Floatmu; it is parameterized by the sizes of the exponent field and the fractional part field.","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"Floatmu{szE,szf}","category":"page"},{"location":"manual.html#MicroFloatingPoints.Floatmu","page":"Manual","title":"MicroFloatingPoints.Floatmu","text":"Floatmu{szE,szf} <: AbstractFloat\n\nIEEE 754-compliant floating-point number with szE bits for the exponent  and szf bits for the fractional part.\n\nA Floatmu object must always have a precision smaller or equal to that of a single precision float. As a consequence, the following constraints hold:\n\nleftbeginarrayl\ntextszEin28\ntextszfin223\nendarrayright\n\nExamples\n\nCreating a Floatmu type equivalent to Float32:\n\njulia> MyFloat32 = Floatmu{8,23}\nFloatmu{8, 23}\n\njulia> a=MyFloat32(0.1)\n0.1\n\njulia> a == 0.1f0\ntrue\n\n\n\n\n\n","category":"type"},{"location":"manual.html#Creating-a-Floatmu-float","page":"Manual","title":"Creating a Floatmu float","text":"","category":"section"},{"location":"manual.html","page":"Manual","title":"Manual","text":"A Floatmu object may be created from a float from a standard floating-point type (Float16, Float32, Float64).","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"using MicroFloatingPoints","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"julia> Floatmu{8,23}(Float16(0.1))\n0.099975586\njulia> Floatmu{8,23}(0.1f0)\n0.1\njulia> Floatmu{8,23}(0.1)\n0.1","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"Note that, depending on the value and the size of the Floatmu type, some rounding may occur. ","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"julia> Floatmu{2,2}(0.1f0)\n0.0\njulia> Floatmu{8,7}(0.1f0)\n0.1","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"Each Floatmu object retains the sign of the error due to rounding the value used to create it. That sign may be obtained with the method errorsign. If one is only interested in obtaining a boolean to know whether some rounding took place or not, one can use the isinexact method instead.","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"errorsign(x::Floatmu{szE,szf}) where {szE,szf}\nisinexact(x::Floatmu{szE,szf}) where {szE,szf}","category":"page"},{"location":"manual.html#MicroFloatingPoints.errorsign-Union{Tuple{Floatmu{szE, szf}}, Tuple{szf}, Tuple{szE}} where {szE, szf}","page":"Manual","title":"MicroFloatingPoints.errorsign","text":"errorsign(x::Floatmu{szE,szf}) where {szE,szf}\n\nReturn 1 if x was rounded by excess when created as a Floatmu{szE,szf}, -1 if it was rounded by default, and 0 if no rounding took place.\n\nAn NaN is never in error. An infinite is in error only if created from a finite value.\n\nSee\n\nisinexact(x::Floatmu{szE,szf}) where {szE,szf}\nreset_inexact()\ninexact()\n\nExamples\n\njulia> errorsign(Floatmu{2, 2}(0.5))\n0\njulia> errorsign(Floatmu{2, 2}(1.7))\n1\njulia> errorsign(Floatmu{2, 2}(-2.8))\n-1\n\n\n\n\n\n","category":"method"},{"location":"manual.html#MicroFloatingPoints.isinexact-Union{Tuple{Floatmu{szE, szf}}, Tuple{szf}, Tuple{szE}} where {szE, szf}","page":"Manual","title":"MicroFloatingPoints.isinexact","text":"isinexact(x::Floatmu{szE,szf}) where {szE,szf}\n\nReturn true if the value x was rounded when created as a Floatmu{szE,szf} and  false otherwise.\n\nAn NaN is never inexact. An infinite is inexact only if created from a finite value.\n\nSee:\n\nerrorsign(x::Floatmu{szE,szf}) where {szE,szf}.\nreset_inexact()\ninexact()\n\nExamples\n\njulia> isinexact(Floatmu{2, 2}(0.25)+Floatmu{2, 2}(2.0))\ntrue\njulia> isinexact(Floatmu{2, 2}(0.25)+Floatmu{2, 2}(1.5))\nfalse\n\n\n\n\n\n","category":"method"},{"location":"manual.html","page":"Manual","title":"Manual","text":"warning: Rounding information\nBe wary of the fact that a Floatmu object is completely oblivious to rounding  that may have occurred before the call of its constructor. julia> isinexact(Floatmu{8,23}(Float16(0.1)))\nfalseIn the preceding example, no rounding is reported even though 0.1 is not  representable in binary because the Floatmu is created from a Float16  approximation of it and a Floatmu{8,23} object has more precision than  a Float16. The rounding that took place when creating the Float16 in the first place goes unreported.","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"It is also possible to create a Floatmu float from an integer of the type Int64:","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"julia> Floatmu{8,7}(10)\n10.0","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"Due to the limited range of the Floatmu type, some rounding may still occur:","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"julia> Floatmu{8,7}(303)\n304.0","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"It is possible to know the largest positive integer such that all smaller integers are represented without rounding using the Base.maxintfloat method:","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"julia> maxintfloat(Floatmu{8,7})\n256.0\njulia> Floatmu{8,7}(257)\n256.0","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"Lastly, a Floatmu may be created from another Floatmu with the same or a different precision and range.","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"julia> Floatmu{5,10}(0.1)==Floatmu{8,7}(Floatmu{5,10}(0.1))\nfalse","category":"page"},{"location":"manual.html#Characteristics-of-a-Floatmu","page":"Manual","title":"Characteristics of a Floatmu","text":"","category":"section"},{"location":"manual.html","page":"Manual","title":"Manual","text":"It is possible to obtain some characteristics of a Floatmu type by using standard Julia methods. Most of them are usually undocumented, being internal to the Base package. Since the intended audience for the MicroFloatingPoints package is probably more interested in these methods than the general public, we document them here.","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"The Base.precision() method returns the number of bits in the significand:","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"julia> Base.precision(Floatmu{8,23})\n24","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"The Base.exponent_max and Base.exponent_raw_max return, respectively, the maximum unbiased exponent and the maximum biased exponent. ","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"julia> Base.exponent_max(Floatmu{8,23})\n127\njulia> Base.exponent_raw_max(Floatmu{8,23})\n255","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"Some other methods in the MicroFloatingPoints package are related to the exponent of a Floatmu:","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"Emax(::Type{Floatmu{szE,szf}}) where {szE, szf}\nEmin(::Type{Floatmu{szE,szf}}) where {szE, szf}\nbias(::Type{Floatmu{szE,szf}}) where {szE, szf}","category":"page"},{"location":"manual.html#MicroFloatingPoints.Emax-Union{Tuple{Type{Floatmu{szE, szf}}}, Tuple{szf}, Tuple{szE}} where {szE, szf}","page":"Manual","title":"MicroFloatingPoints.Emax","text":"Emax(::Type{Floatmu{szE,szf}}) where {szE, szf}\n\nMaximum unbiased exponent for a Floatmu{szE,szf} returned as an UInt32.\n\nSee: exponent_max, exponent_raw_max, Emin\n\nExamples\n\njulia> Emax(Floatmu{8, 23})\n0x0000007f\n\n\n\n\n\n","category":"method"},{"location":"manual.html#MicroFloatingPoints.Emin-Union{Tuple{Type{Floatmu{szE, szf}}}, Tuple{szf}, Tuple{szE}} where {szE, szf}","page":"Manual","title":"MicroFloatingPoints.Emin","text":"Emin(::Type{Floatmu{szE,szf}}) where {szE, szf}\n\nMinimum unbiased exponent for a Floatmu{szE,szf} returned as an Int32.\n\nSee: exponent_max, exponent_raw_max, Emax\n\nExamples\n\njulia> Emin(Floatmu{8, 23})\n-126\n\n\n\n\n\n","category":"method"},{"location":"manual.html#MicroFloatingPoints.bias-Union{Tuple{Type{Floatmu{szE, szf}}}, Tuple{szf}, Tuple{szE}} where {szE, szf}","page":"Manual","title":"MicroFloatingPoints.bias","text":"bias(::Type{Floatmu{szE,szf}}) where {szE, szf}\n\nBias of the exponent for a Floatmu{szE,szf}.\n\nExamples\n\njulia> bias(Floatmu{8, 23}) \n0x0000007f\n\n\n\n\n\n","category":"method"},{"location":"manual.html","page":"Manual","title":"Manual","text":"Other methods return remarkable values for the type:","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"Infμ(::Type{Floatmu{szE,szf}}) where {szE,szf}\nNaNμ(::Type{Floatmu{szE,szf}}) where {szE, szf}\neps(::Type{Floatmu{szE,szf}})  where {szE,szf}\nλ(::Type{Floatmu{szE,szf}})  where {szE,szf}\nμ(::Type{Floatmu{szE,szf}})  where {szE,szf}\nsign(x::Floatmu{szE,szf}) where {szE, szf}\nfloatmax(::Type{Floatmu{szE,szf}})  where {szE,szf}\nfloatmin(::Type{Floatmu{szE,szf}})  where {szE,szf}\ntypemin(::Type{Floatmu{szE,szf}})  where {szE,szf}\ntypemax(::Type{Floatmu{szE,szf}})  where {szE,szf}\nmaxintfloat(::Type{Floatmu{szE,szf}})  where {szE,szf}\n","category":"page"},{"location":"manual.html#MicroFloatingPoints.Infμ-Union{Tuple{Type{Floatmu{szE, szf}}}, Tuple{szf}, Tuple{szE}} where {szE, szf}","page":"Manual","title":"MicroFloatingPoints.Infμ","text":"Infμ(::Type{Floatmu{szE,szf}}) where {szE,szf}\n\nPositive infinite value in the format Floatmu{szE,szf}.\n\nExamples\n\njulia> Infμ(Floatmu{8, 23}) == Inf32\ntrue\n\n\n\n\n\n","category":"method"},{"location":"manual.html#MicroFloatingPoints.NaNμ-Union{Tuple{Type{Floatmu{szE, szf}}}, Tuple{szf}, Tuple{szE}} where {szE, szf}","page":"Manual","title":"MicroFloatingPoints.NaNμ","text":"NaNμ(::Type{Floatmu{szE,szf}}) where {szE, szf}\n\nNaN in the format Floatmu{szE,szf}.\n\nThe canonical NaN value has a sign bit set to zero and all bits of the fractional part set to zero except for the leftmost one.\n\nExamples\n\njulia> isnan(NaNμ(Floatmu{2, 2}))\ntrue\njulia> NaNμ(Floatmu{2, 2})\nNaNμ{2, 2}\n\n\n\n\n\n","category":"method"},{"location":"manual.html#Base.eps-Union{Tuple{Type{Floatmu{szE, szf}}}, Tuple{szf}, Tuple{szE}} where {szE, szf}","page":"Manual","title":"Base.eps","text":"eps(::Type{Floatmu{szE,szf}})  where {szE,szf}\n\nReturn the epsilon of the type Floatmu{szE,szf}, which is the  difference between 1.0 and the next float.\n\nExamples\n\njulia> eps(Floatmu{2, 2})\n0.25\n\njulia> eps(Floatmu{3, 5})\n0.0312\n\njulia> eps(Floatmu{8, 23})==eps(Float32)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"manual.html#MicroFloatingPoints.λ-Union{Tuple{Type{Floatmu{szE, szf}}}, Tuple{szf}, Tuple{szE}} where {szE, szf}","page":"Manual","title":"MicroFloatingPoints.λ","text":"λ(::Type{Floatmu{szE,szf}})  where {szE,szf}\n\nReturn λ, the smallest positive normal number of the type Floatmu{szE,szf}.\n\nExamples\n\njulia> λ(Floatmu{2, 2})\n1.0\n\njulia> λ(Floatmu{8, 23})==floatmin(Float32)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"manual.html#MicroFloatingPoints.μ-Union{Tuple{Type{Floatmu{szE, szf}}}, Tuple{szf}, Tuple{szE}} where {szE, szf}","page":"Manual","title":"MicroFloatingPoints.μ","text":"μ(::Type{Floatmu{szE,szf}})  where {szE,szf}\n\nReturn μ, the smallest positive subnormal number of type Floatmu{szE,szf}.\n\nExamples\n\njulia> μ(Floatmu{2, 2})\n0.25\n\n\n\n\n\n","category":"method"},{"location":"manual.html#Base.sign-Union{Tuple{Floatmu{szE, szf}}, Tuple{szf}, Tuple{szE}} where {szE, szf}","page":"Manual","title":"Base.sign","text":"sign(x::Floatmu{szE,szf}) where {szE, szf}\n\nReturn x if x is zero, 1.0 if x is strictly positive and -1.0 if x is strictly negative. Return NaN if x is a Not a Number.\n\nExamples\n\njulia> sign(Floatmu{2, 3}(-1.6))\n-1.0\n\njulia> sign(Floatmu{2, 3}(1.6))\n1.0\n\njulia> sign(Floatmu{2, 3}(NaN))\nNaNμ{2, 3}\n\njulia> sign(Floatmu{2, 3}(-0.0))\n-0.0\n\n\n\n\n\n","category":"method"},{"location":"manual.html#Base.floatmax-Union{Tuple{Type{Floatmu{szE, szf}}}, Tuple{szf}, Tuple{szE}} where {szE, szf}","page":"Manual","title":"Base.floatmax","text":"floatmax(::Type{Floatmu{szE,szf}})  where {szE,szf}\n\nReturn the largest positive normal number of the type Floatmu{szE,szf}.\n\nExamples\n\njulia> floatmax(Floatmu{2, 2})\n3.5\n\njulia> floatmax(Floatmu{8, 23})==floatmax(Float32)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"manual.html#Base.floatmin-Union{Tuple{Type{Floatmu{szE, szf}}}, Tuple{szf}, Tuple{szE}} where {szE, szf}","page":"Manual","title":"Base.floatmin","text":"floatmin(::Type{Floatmu{szE,szf}})  where {szE,szf}\n\nReturn λ, the smallest positive normal number of the type Floatmu{szE,szf}.\n\nExamples\n\njulia> floatmin(Floatmu{2, 2})\n1.0\n\njulia> floatmin(Floatmu{8, 23})==floatmin(Float32)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"manual.html#Base.typemin-Union{Tuple{Type{Floatmu{szE, szf}}}, Tuple{szf}, Tuple{szE}} where {szE, szf}","page":"Manual","title":"Base.typemin","text":"typemin(::Type{Floatmu{szE,szf}})  where {szE,szf}\n\nReturn the negative infinite of the type Floatmu{szE,szf}.\n\nExamples\n\njulia> typemin(Floatmu{3, 5})\n-Infμ{3, 5}\n\n\n\n\n\n","category":"method"},{"location":"manual.html#Base.typemax-Union{Tuple{Type{Floatmu{szE, szf}}}, Tuple{szf}, Tuple{szE}} where {szE, szf}","page":"Manual","title":"Base.typemax","text":"typemax(::Type{Floatmu{szE,szf}})  where {szE,szf}\n\nReturn the positive infinite of the type Floatmu{szE,szf}.\n\nExamples\n\njulia> typemax(Floatmu{3, 5})\nInfμ{3, 5}\n\n\n\n\n\n","category":"method"},{"location":"manual.html#Base.maxintfloat-Union{Tuple{Type{Floatmu{szE, szf}}}, Tuple{szf}, Tuple{szE}} where {szE, szf}","page":"Manual","title":"Base.maxintfloat","text":"maxintfloat(::Type{Floatmu{szE,szf}})  where {szE,szf}\n\nReturn the smallest positive integer n such that n+1 is not representable in the type Floatmu{szE,szf}. The number n is returned as a  Floatmu{szE,szf}. \n\nThe function returns an infinite value if all integers are representable in the domain of normal values.\n\nExamples\n\njulia> maxintfloat(Floatmu{3,2})\n8.0\n\njulia> maxintfloat(Floatmu{2,2})\nInfμ{2, 2}\n\njulia> maxintfloat(Floatmu{8,23})==maxintfloat(Float32)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"manual.html","page":"Manual","title":"Manual","text":"Lastly, some methods test properties on the different parts of a Floatmu:","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"fractional_even(x::Floatmu{szE,szf}) where {szE,szf}","category":"page"},{"location":"manual.html#MicroFloatingPoints.fractional_even-Union{Tuple{Floatmu{szE, szf}}, Tuple{szf}, Tuple{szE}} where {szE, szf}","page":"Manual","title":"MicroFloatingPoints.fractional_even","text":"fractional_even(x::Floatmu{szE,szf}) where {szE,szf}\n\nReturn true if the fractional part of x has a zero as the rightmost bit.\n\nBEWARE: the function does not check whether x is an NaN or an infinite value.\n\n\n\n\n\n","category":"method"},{"location":"manual.html#Tests","page":"Manual","title":"Tests","text":"","category":"section"},{"location":"manual.html","page":"Manual","title":"Manual","text":"signbit(x::Floatmu{szE,szf}) where {szE, szf}\nisnan(x::Floatmu{szE,szf}) where {szE,szf}\nisinf(x::Floatmu{szE,szf}) where {szE,szf}\nisfinite(x::Floatmu{szE,szf}) where {szE,szf}\nissubnormal(x::Floatmu{szE,szf}) where {szE,szf}","category":"page"},{"location":"manual.html#Base.signbit-Union{Tuple{Floatmu{szE, szf}}, Tuple{szf}, Tuple{szE}} where {szE, szf}","page":"Manual","title":"Base.signbit","text":"signbit(x::Floatmu{szE,szf}) where {szE, szf}\n\nReturn true if x is signed and false otherwise. The result for a NaN may vary, depending on the value of its sign bit.\n\nExamples\n\njulia> signbit(Floatmu{2, 3}(1.5))\nfalse\njulia> signbit(Floatmu{2, 3}(-1.5))\ntrue\n\nThe function differentiates between -00 and +00 even though both values test equal.\n\njulia> signbit(Floatmu{2, 3}(-0.0))\ntrue\n\njulia> signbit(Floatmu{2, 3}(0.0))\nfalse\n\n\n\n\n\n","category":"method"},{"location":"manual.html#Base.isnan-Union{Tuple{Floatmu{szE, szf}}, Tuple{szf}, Tuple{szE}} where {szE, szf}","page":"Manual","title":"Base.isnan","text":"isnan(x::Floatmu{szE,szf}) where {szE,szf}\n\nReturn true if x is a Not an Number and false otherwise.\n\nExamples\n\njulia> isnan(Floatmu{2, 3}(1.5))\nfalse\n\njulia> isnan(Floatmu{2, 3}(NaN))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"manual.html#Base.isinf-Union{Tuple{Floatmu{szE, szf}}, Tuple{szf}, Tuple{szE}} where {szE, szf}","page":"Manual","title":"Base.isinf","text":"isinf(x::Floatmu{szE,szf}) where {szE,szf}\n\nReturn true if x is an infinity and false otherwise.\n\nExamples\n\njulia> isinf(Floatmu{2, 2}(1.5))\nfalse\n\njulia> isinf(Floatmu{2, 2}(-Inf))\ntrue\n\njulia> isinf(Floatmu{2, 2}(9.8))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"manual.html#Base.isfinite-Union{Tuple{Floatmu{szE, szf}}, Tuple{szf}, Tuple{szE}} where {szE, szf}","page":"Manual","title":"Base.isfinite","text":"isfinite(x::Floatmu{szE,szf}) where {szE,szf}\n\nReturn true if x is finite and false otherwise. An NaN is not finite.\n\nExamples\n\njulia> isfinite(Floatmu{2, 2}(1.5))\ntrue\n\njulia> isfinite(Floatmu{2, 2}(3.8))\nfalse\n\njulia> isfinite(Floatmu{2, 2}(NaN))\nfalse\n\n\n\n\n\n","category":"method"},{"location":"manual.html#Base.issubnormal-Union{Tuple{Floatmu{szE, szf}}, Tuple{szf}, Tuple{szE}} where {szE, szf}","page":"Manual","title":"Base.issubnormal","text":"issubnormal(x::Floatmu{szE,szf}) where {szE,szf}\n\nReturn true if x is a subnormal number and false otherwise. According to the definition, ±0.0 is not a subnormal number.\n\nExamples\n\njulia> issubnormal(Floatmu{2, 2}(1.0))\nfalse\n\njulia> issubnormal(Floatmu{2, 2}(0.25))\ntrue\n\njulia> issubnormal(Floatmu{2, 2}(0.0))\nfalse\n\n\n\n\n\n","category":"method"},{"location":"manual.html#Conversions","page":"Manual","title":"Conversions","text":"","category":"section"},{"location":"manual.html","page":"Manual","title":"Manual","text":"A Floatmu may be converted from and to any of the standard floating-point type (Float16, Float32, Float64).","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"convert","category":"page"},{"location":"manual.html#Base.convert","page":"Manual","title":"Base.convert","text":"convert(::Type{Float64}, x::Floatmu{szE,szf}) where {szE, szf}\nconvert(::Type{Float32}, x::Floatmu{szE,szf}) where {szE, szf}\nconvert(::Type{Float16}, x::Floatmu{szE,szf}) where {szE, szf}\nconvert(::Type{Floatmu{szE,szf} where {szE,szf}}, x::Float64)\nconvert(::Type{Floatmu{szE,szf} where {szE,szf}}, x::Float32)\nconvert(::Type{Floatmu{szE,szf} where {szE,szf}}, x::Float16)\n\nConvert a Floatmu to a double, single or half precision float, or vice-versa. For the double precision,  the conversion never introduces errors since Float64 objects have at least twice the precision  of the fractional part of a Floatmu object.\n\nExamples\n\njulia> convert(Float64,Floatmu{8, 23}(0.1))\n0.10000000149011612\n\njulia> convert(Float32,Floatmu{8, 23}(0.1)) == 0.1f0\ntrue\n\njulia> convert(Float32,Floatmu{5, 10}(0.1)) == Float16(0.1)\ntrue\n\njulia> convert(Floatmu{2, 4},0.1)\n0.125\n\njulia> convert(Floatmu{2, 4},0.1f0)\n0.125\n\njulia> convert(Floatmu{2, 4},Float16(0.1))\n0.125\n\njulia> Floatmu{5, 10}(0.1)==Float16(0.1)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"manual.html","page":"Manual","title":"Manual","text":"A Floatmu may also be created from a string:","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"parse(::Type{Floatmu{szE,szf}}, str::AbstractString) where {szE, szf}\ntryparse(::Type{Floatmu{szE,szf}}, str::AbstractString) where {szE, szf}","category":"page"},{"location":"manual.html#Base.parse-Union{Tuple{szf}, Tuple{szE}, Tuple{Type{Floatmu{szE, szf}}, AbstractString}} where {szE, szf}","page":"Manual","title":"Base.parse","text":"parse(::Type{Floatmu{szE,szf}}, str::AbstractString) where {szE, szf}\n\nParse the string str representing a floating-point number and convert it  to a Floatmu{szE,szf} object.\n\nExamples\n\njulia> parse(Floatmu{5, 7},\"0.1\")\n0.1\n\njulia> parse(Floatmu{5, 7},\"1.0e10\")\nInfμ{5, 7}\n\nThe string is first converted to a Float64 and then rounded to the precision of  the Floatmu object. If the string cannot be converted to a Float64, the ArgumentError exception is thrown.\n\nExamples\n\njulia> parse(Floatmu{5, 7},\"0.1a\")\nERROR: ArgumentError: cannot parse \"0.1a\" as a Floatmu{5, 7}\n\n\n\n\n\n","category":"method"},{"location":"manual.html#Base.tryparse-Union{Tuple{szf}, Tuple{szE}, Tuple{Type{Floatmu{szE, szf}}, AbstractString}} where {szE, szf}","page":"Manual","title":"Base.tryparse","text":"tryparse(::Type{Floatmu{szE,szf}}, str::AbstractString) where {szE, szf}\n\nParse the string str representing a floating-point number and convert it  to a Floatmu{szE,szf} object.\n\nExamples\n\njulia> tryparse(Floatmu{5, 7},\"0.1\")\n0.1\n\njulia> tryparse(Floatmu{5, 7},\"1.0e10\")\nInfμ{5, 7}\n\nThe string is first converted to a Float64 and then rounded to the precision of  the Floatmu object. Contrary to parse, if the string cannot be converted to a Float64, the value nothing is returned.\n\nExamples\n\njulia> tryparse(Floatmu{5, 7},\"0.1a\") == nothing\ntrue\n\n\n\n\n\n","category":"method"},{"location":"manual.html#Display","page":"Manual","title":"Display","text":"","category":"section"},{"location":"manual.html","page":"Manual","title":"Manual","text":"Contrary to a Float16 or a Float32, which are displayed by default with an indication of their type, a Floatmu is displayed as a number alone with no indication of its type (much like a Float64).","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"julia> Floatmu{2,2}(0.25)\n0.25","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"It is also possible to display the internal representation of a Floatmu{szE,szf} as an 1+textszE+textszf bit string:","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"bitstring(x::Floatmu{szE,szf}) where {szE,szf}","category":"page"},{"location":"manual.html#Base.bitstring-Union{Tuple{Floatmu{szE, szf}}, Tuple{szf}, Tuple{szE}} where {szE, szf}","page":"Manual","title":"Base.bitstring","text":"bitstring(x::Floatmu{szE,szf}) where {szE,szf}\n\nReturn the string of bits representing internally the value x.\n\nExamples\n\njulia> bitstring(Floatmu{2, 2}(1.5))\n\"00110\"\n\njulia> bitstring(Floatmu{2, 2}(0.5))\n\"00010\"\n\njulia> bitstring(Floatmu{8, 23}(0.1))==bitstring(0.1f0)\ntrue\n\njulia> bitstring(Floatmu{8, 23}(Inf)) == bitstring(Inf32)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"manual.html#Iterating-through-floats","page":"Manual","title":"Iterating through floats","text":"","category":"section"},{"location":"manual.html","page":"Manual","title":"Manual","text":"As for the standard floating-point types, it is possible to go from one Floatmu to the next using nextfloat and prevfloat.","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"prevfloat(x::Floatmu{szE,szf}, n::UInt32 = 1) where {szE,szf}\nnextfloat(x::Floatmu{szE,szf}, n::UInt32 = 1) where {szE,szf}","category":"page"},{"location":"manual.html#Base.prevfloat-Union{Tuple{Floatmu{szE, szf}}, Tuple{szf}, Tuple{szE}, Tuple{Floatmu{szE, szf}, UInt32}} where {szE, szf}","page":"Manual","title":"Base.prevfloat","text":"prevfloat(x::Floatmu{szE,szf}, n::UInt32 = 1) where {szE,szf}\n\nReturn the Floatmu{szE,szf} float that is n floats before x in the natural order of floats.  Return NaNμ{szE,szf} if x is Not a Number. Return -Infμ{szE,szf} if there are less than n finite floats before x on the real line.\n\nExamples\n\njulia> prevfloat(Floatmu{2, 2}(1.0),2)\n0.5\n\njulia> prevfloat(Floatmu{2, 2}(-0.0))\n-0.25\n\njulia> prevfloat(Floatmu{2, 2}(Inf))\n3.5\n\njulia> prevfloat(Floatmu{2, 2}(0.25))\n0.0\n\n\n\n\n\n","category":"method"},{"location":"manual.html#Base.nextfloat-Union{Tuple{Floatmu{szE, szf}}, Tuple{szf}, Tuple{szE}, Tuple{Floatmu{szE, szf}, UInt32}} where {szE, szf}","page":"Manual","title":"Base.nextfloat","text":"nextfloat(x::Floatmu{szE,szf}, n::UInt32 = 1) where {szE,szf}\n\nReturn the Floatmu{szE,szf} float that is n floats after x in the natural order of floats.  Return NaNμ{szE,szf} if x is Not a Number. Return Infμ{szE,szf} if there are less than n finite floats after x on the real line.\n\nExamples\n\njulia> nextfloat(Floatmu{2, 2}(3.5))\nInfμ{2, 2}\n\njulia> nextfloat(Floatmu{2, 2}(0.0),3)\n0.75\n\njulia> nextfloat(Floatmu{2, 2}(-Inf))\n-3.5\n\njulia> nextfloat(Floatmu{2, 2}(-0.25))\n-0.0\n\n\n\n\n\n","category":"method"},{"location":"manual.html","page":"Manual","title":"Manual","text":"A FloatmuIterator allows to iterate on a range of Floatmu in a more systematic way:","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"FloatmuIterator{szE,szf}","category":"page"},{"location":"manual.html#MicroFloatingPoints.FloatmuIterator","page":"Manual","title":"MicroFloatingPoints.FloatmuIterator","text":"FloatmuIterator(start::Floatmu{szE,szf},stop::Floatmu{szE,szf},\n                step::Floatmu{szE,szf}) where {szE,szf}\nFloatmuIterator(start::Floatmu{szE,szf},stop::Floatmu{szE,szf},\n                step::Float64) where {szE,szf}\nFloatmuIterator(start::Floatmu{szE,szf},stop::Floatmu{szE,szf},\n                step::Int = 1) where {szE,szf}\nFloatmuIterator(::Type{Floatmu{szE,szf}},start::Float64,stop::Float64,\n                step::Int = 1) where {szE,szf}\nFloatmuIterator(::Type{Floatmu{szE,szf}},start::Float64,stop::Float64,\n                step::Float64) where {szE,szf}\n\nIterator to generate all Floatmu{szE,szf} in the domain [start,stop]. The iterator can be initialized with two Floatmu{szE,szf} or with two Float64. \n\nOne may iterate from one float to the next (the default) or choose some step.  The step may be a number of floats or an amount to add.\n\nAn ArgumentError is raised if the bounds are NaNs, if the step chosen is zero (or rounds to zero when converted to a Floatmu{szE,szf}), or if the step is a value smaller than the largest distance between two consecutive floats in [last, stop] (use eligible_step to know the smallest value allowed).\n\nWhen the step is an amount to add, the bounds cannot be infinities. \n\nWhen the step is a number of floats, infinities are allowed for the bounds and are always part of the resulting range:\n\njulia> collect(FloatmuIterator(Floatmu{2,2},-Inf,Inf,5))\n6-element Vector{Floatmu{2, 2}}:\n -Infμ{2, 2}\n  -1.75\n  -0.5\n   0.75\n   2.0\n  Infμ{2, 2}\n\nExamples\n\njulia> L=[x for x = FloatmuIterator(Floatmu{2, 2}(0.0), Floatmu{2, 2}(1.0))]\n5-element Vector{Floatmu{2, 2}}:\n 0.0\n 0.25\n 0.5\n 0.75\n 1.0\njulia> L2=[x for x = FloatmuIterator(Floatmu{2, 2}, 0.0, 1.0, 2)]\n3-element Vector{Floatmu{2, 2}}:\n 0.0\n 0.5\n 1.0\n\n\n\n\n\n","category":"type"},{"location":"manual.html","page":"Manual","title":"Manual","text":"warning: Effect of rounding on iterations\nKeep in mind that the bounds of the iterator may need rounding when converted to a Floatmu, so that the number of iterations may not be the one expected.  Additionnally, the step chosen may induce more rounding at each iteration.Examplejulia> [x for x in FloatmuIterator(Floatmu{2,2},-1.2,-0.2,0.3)]\n4-element Vector{Floatmu{2,2}}:\n-1.25\n-1.0\n-0.75\n-0.5\n\njulia> FloatmuIterator(Floatmu{2,2},-1.2,-0.2,0.3)\nFloatmuIterator{2,2}(-1.25, -0.25, 0.25)","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"It is possible to know in advance the number of floats in the resulting range with the length function.\t","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"As stated in the documentation for FloatmuIterator above, one cannot use a floating-point step smaller than the largest gap in the domain we iterate through. The function eligible_step gives the smallest value allowed when given two bounds.","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"eligible_step","category":"page"},{"location":"manual.html#MicroFloatingPoints.eligible_step","page":"Manual","title":"MicroFloatingPoints.eligible_step","text":"eligible_step(start::Floatmu{szE,szf}, stop::Floatmu{szE,szf}) where {szE,szf}\neligible_step(::Type{Floatmu{szE,szf}}, start::Float64, stop::Float64) where {szE,szf}\n\nReturn the smallest Floatmu{szE,szf} eligible step allowed to iterate through the domain [start,stop].\n\nExamples\n\njulia> eligible_step(Floatmu{2,2}(-0.5),Floatmu{2,2}(2.5))\n0.5\n\n\n\n\n\n","category":"function"},{"location":"manual.html#Rounding","page":"Manual","title":"Rounding","text":"","category":"section"},{"location":"manual.html","page":"Manual","title":"Manual","text":"We have seen in section Creating a Floatmu float that each Floatmu retains the information whether the value it was created from required rounding or not.","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"In addition to that mechanism, the MicroFloatingPoints module keeps a global variable that is set to true every time a Floatmu is created and rounding takes place. That variable is sticky (once true, it stays true until reset explictly to false). It can be checked with the inexact() method and reset with the reset_inexact() method.","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"inexact()\nreset_inexact()","category":"page"},{"location":"manual.html#MicroFloatingPoints.inexact-Tuple{}","page":"Manual","title":"MicroFloatingPoints.inexact","text":"inexact()\n\nReturn the value of the global inexact flag.\n\n\n\n\n\n","category":"method"},{"location":"manual.html#MicroFloatingPoints.reset_inexact-Tuple{}","page":"Manual","title":"MicroFloatingPoints.reset_inexact","text":"reset_inexact()\n\nReset the global inexact flag to false.\n\n\n\n\n\n","category":"method"},{"location":"manual.html","page":"Manual","title":"Manual","text":"With these methods, one can check whether some computation needed rounding at some point:","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"julia> reset_inexact()\n\njulia> inexact()\nfalse\n\njulia> Floatmu{2,2}(2.0)+Floatmu{2,2}(0.25)\n2.0\n\njulia> inexact()\ntrue\n\njulia> reset_inexact()\n\njulia> Floatmu{2,2}(2.0)+Floatmu{2,2}(0.25)+Floatmu{2,2}(0.25)\n2.0\n\njulia> inexact()\ntrue","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"Note that, in the first example, the result of the computation needed rounding, while in the second example, the output is representable but one of the intermediary computation needed rounding. ","category":"page"},{"location":"manual.html#The-MicroFloatingPoints.MFPUtils-module","page":"Manual","title":"The MicroFloatingPoints.MFPUtils module","text":"","category":"section"},{"location":"manual.html","page":"Manual","title":"Manual","text":"CurrentModule = MicroFloatingPoints.MFPUtils","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"The MicroFloatingPoints.MFPUtils module offers some utiliy functions to be used either by other modules of the MicroFloatingPoints package or directly by the end user.","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"vertical_popcount(T::Vector{Floatmu{szE,szf}}) where {szE,szf}","category":"page"},{"location":"manual.html#MicroFloatingPoints.MFPUtils.vertical_popcount-Union{Tuple{Array{Floatmu{szE, szf}, 1}}, Tuple{szf}, Tuple{szE}} where {szE, szf}","page":"Manual","title":"MicroFloatingPoints.MFPUtils.vertical_popcount","text":"vertical_popcount(T::Vector{Floatmu{szE,szf}}) where {szE,szf}\n\nReturn a vector R of size 1+szE+szf where R[i] is the number of times the i-th bit of the values in T was equal to 1. \n\nFor this function, the rightmost bit of the binary representation of a Floatmu has index 1 and not 0 as usual.\n\nExamples\n\njulia> join(string.(reverse(vertical_popcount(Floatmu{2,2}[1.5])))) == bitstring(Floatmu{2,2}(1.5))\ntrue\n\nNote that, in the preceding example, we have to revert the array obtained from vertical_popcount because the number of times bit i is 1 is saved at position i. As a consequence, the value for the rightmost bit of a Floatmu appears at the leftmost position of the counting array.\n\njulia> println(vertical_popcount(Floatmu{2,2}[0.25,1.5,3.0]))\n[1, 2, 1, 1, 0]\n\n\n\n\n\n","category":"method"},{"location":"manual.html#The-MicroFloatingPoints.MFPRandom-module","page":"Manual","title":"The MicroFloatingPoints.MFPRandom module","text":"","category":"section"},{"location":"manual.html","page":"Manual","title":"Manual","text":"CurrentModule = MicroFloatingPoints.MFPRandom","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"The MicroFloatingPoints.MFPRandom module overloads rand to offer Floatmu floating-point numbers drawn at random in 01). The method uses Random.rand under the hood. It is then affected in the same way by  Random.seed!.","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"julia> Random.seed!(42);\n\njulia> rand(Floatmu{2,2})\n\njulia> rand(Floatmu{2,2})","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"It is possible to draw Floatmu values at random in the same way as with other floating-point types:","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"julia> rand(Floatmu{2,2},5)","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"Using the Distributions package, one can also draw Floatmu numbers with other distributions:","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"julia> rand(Uniform(Floatmu{2,2}(-1.0),Floatmu{2,2}(1.0)))","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"warning: Using custom distributions\nOne must be wary of very small Floatmu types when using other distributions than U01) as the computation necessary to compute another distribution may  easily involve larger numbers than can be represented with the type. Consider, for example, the type Floatmu{2,2} whose largest positive finite value is 3.0.  If we decide to draw numbers in the domain -22), we will call:rand(Uniform(Floatmu{2,2}(-2.0),Floatmu{2,2}(2.0)))To translate the distribution from 01) to -22), the Uniform method will draw a value x in 01) and apply the formula a+(b-a)x, with a=-2 and b=2. Unfortunately, b-a will then be  textFloatmu22(20)-textFloatmu22(-20), which is rounded to  Infμ{2,2}. Consequently, we will always draw the same infinite value:julia> rand(Uniform(Floatmu{2,2}(-2.0),Floatmu{2,2}(2.0)))\nInfμ{2, 2}\n\njulia> rand(Uniform(Floatmu{2,2}(-2.0),Floatmu{2,2}(2.0)))\nInfμ{2, 2}\n","category":"page"},{"location":"manual.html#The-MicroFloatingPoints.MFPPlot-module","page":"Manual","title":"The MicroFloatingPoints.MFPPlot module","text":"","category":"section"},{"location":"manual.html","page":"Manual","title":"Manual","text":"CurrentModule = MicroFloatingPoints.MFPPlot","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"The MicroFloatingPoints.MFPPlot module offers some methods to easily represent floating-point numbers.","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"real_line","category":"page"},{"location":"manual.html#MicroFloatingPoints.MFPPlot.real_line","page":"Manual","title":"MicroFloatingPoints.MFPPlot.real_line","text":"real_line(start::Floatmu{szE,szf}, stop::Floatmu{szE,szf};\n          ticks = true, \n          fpcolorsub = \"purple\", fpcolornorm = \"blue\") where {szE,szf}\nreal_line(::Type{Floatmu{szE,szf}};\n          ticks = true, \n          fpcolorsub = \"purple\", fpcolornorm = \"blue\",\n          fpcolorinf=\"orange\") where {szE,szf}\nreal_line(T::Vector{Floatmu{szE,szf}};\n               ticks = true, fpcolorsub = \"purple\", fpcolornorm = \"blue\",\n               fpcolorinf=\"orange\") where {szE,szf}\n\nDraw floats on the real line.\n\nThe first version draws the real line between start and stop and displays all floating-point numbers with sze bits exponent and szf bits fractional part. The second version draws all finite  floating-point for the format Floatmu{szE,szf} and adds the infinities where the next/previous  float would be with the format Floatmu{szE+1,szf}. The third version draws all floats in the  vector T.\n\nIn the first version, both parameters start and stop must be finite. An ArgumentError exception is raised otherwise. The same goes for all values in T for the third version.\n\nAll versions return the figure used for the plot.\n\nThe figure may be customized through the named parameters:\n\nticks: if true, draws a vertical line for each float and adds the value below. If   false, represent each float by a dot on the real line, without its value;\nfpcolorsub: color of the line or dot used to represent subnormals;\nfpcolornorm: color of the line or dot used to represent normal values;\nfpcolorinf [for the second version only]: color of the line or dot used to represent infinite values.\n\nExamples of calls\n\nreal_line(-floatmax(Floatmu{2,2}),floatmax(Floatmu{2,2}));\nreal_line(Floatmu{2,2});\nreal_line(Floatmu{2,2}[-3.5,0.25,1.5,2.0])\n\n\n\n\n\n","category":"function"},{"location":"manual.html#Examples","page":"Manual","title":"Examples","text":"","category":"section"},{"location":"manual.html","page":"Manual","title":"Manual","text":"using MicroFloatingPoints, MicroFloatingPoints.MFPPlot, PyPlot\nplt.figure()","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"real_line(Floatmu{2,3}(-2.5),Floatmu{2,3}(1.0));\nsavefig(\"realline_Floatmu23a.svg\"); nothing # hide","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"<div style=\"text-align: center\">\n<img src=\"./realline_Floatmu23a.svg\" alt=\"Floatmu{2,3} values in [-2.5, 1.0]\" />\n</div>","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"plt.figure()","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"real_line(Floatmu{2,3});\nsavefig(\"realline_Floatmu23b.svg\"); nothing # hide","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"<div style=\"text-align: center\">\n<img src=\"./realline_Floatmu23b.svg\" alt=\"Floatmu{2,3} finite and infinite values\" />\n</div>","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"bits_histogram(T::Vector{Floatmu{szE,szf}}) where {szE,szf}","category":"page"},{"location":"manual.html#MicroFloatingPoints.MFPPlot.bits_histogram-Union{Tuple{Array{Floatmu{szE, szf}, 1}}, Tuple{szf}, Tuple{szE}} where {szE, szf}","page":"Manual","title":"MicroFloatingPoints.MFPPlot.bits_histogram","text":"bits_histogram(T::Vector{Floatmu{szE,szf}};\n               signcolor = \"magenta\",\n               expcolor = \"darkolivegreen\",\n               fraccolor = \"blue\") where {szE,szf}\n\nDraw an histogram of the probability of each bit of the representation of a float to be 1 in the sample T.\n\n\n\n\n\n","category":"method"},{"location":"manual.html","page":"Manual","title":"Manual","text":"using MicroFloatingPoints, MicroFloatingPoints.MFPPlot, PyPlot\nplt.figure()","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"T=collect(FloatmuIterator(Floatmu{3,5},0.0,1.0,2.0^-6));\nbits_histogram(T)\nsavefig(\"bits_histogram.svg\"); nothing # hide","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"<div style=\"text-align: center\">\n<img src=\"./bits_histogram.svg\" alt=\"Floatmu{3,4} bits histogram in [0, 1]\" />\n</div>","category":"page"},{"location":"index.html#MicroFloatingPoints","page":"Home","title":"MicroFloatingPoints","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The MicroFloatingPoints package allows to manipulate small IEEE 754-compliant floating-point numbers, aka. minifloats, which are smaller or equal to the Float32 format mandated by the standard.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The library may serve to exemplify the behavior of IEEE 754 floating-point numbers in a systematic way through the use of very small formats.","category":"page"},{"location":"index.html#Presentation","page":"Home","title":"Presentation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"At its core, the package defines a new type Floatmu parameterized by two integers:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"szE, the number of bits used to represent the exponent;\nszf, the number of bits used to represent the fractional part (excluding the so-called hidden bit).","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"As the figure below shows, the total length of an object of the type Floatmu{szE,szf} is 1+textszE+textszf bits[1].","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"[1]: The size of the object representing a Floatmu may be much larger however, as it corresponds currently to two 32 bits unsigned integers per Floatmu.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"<div style=\"text-align: center\">\n<img src=\"./floatmu-bit-representation.svg\" alt=\"Floatmu bit representation\" />\n</div>","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Floatmu{szE,szf} objects are stored in 32 bit unsigned integers, which puts a limit on the maximum value of szE and szf. All computations are performed internally with double precision Float64 floats. To ensure that no double rounding will occur, viz. that the computation performed in double precision, once rounded to a Floatmu{szE,szf}, will give a result identical to the one we would have obtained had we performed it entirely with the precision of the Floatmu{szE,szf} type, we limit the size of a Floatmu{szE,szf} to that of a Float32 [Rump2016].","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"[Rump2016]: IEEE754 Precision-k base-beta Arithmetic Inherited by Precision-m Base-beta Arithmetic for km. Siegfried M. Rump, ACM Transactions on Mathematical Software, Vol. 43, N° 3. December 2016.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The limits on the integers szE and szf are therefore:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"leftbeginarrayl\n2leqslanttextszEleqslant8\n2leqslanttextszfleqslant23\nendarrayright","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Under these constraints, one can manipulate and compute with very small floats (e.g. 2 bits for the exponent and 2 bits for the fractional part) that comply with the IEEE 754 standard. It is also possible to emulate more established formats such as:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Float16, the IEEE 754 half-precision format: Floatmu{5,10}\nFloat32, the IEEE 754 single precision format: Floatmu{8,23}\nbfloat16, the Brain Floating Point by Google: Floatmu{8,7}\nTensorFloat-32, the format by NVIDIA: Floatmu{8,10}\nAMD's fp24: Floatmu{7,16}\nPixar's PXR24: Floatmu{8,15}\nand many more…","category":"page"},{"location":"index.html#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The package can be installed with the Julia package manager. From the Julia REPL, type ] to enter the Pkg REPL mode and run:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"pkg> add MicroFloatingPoints","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Or, equivalently, via the Pkg API:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> import Pkg; Pkg.add(\"MicroFloatingPoints\")","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Note that the matplotlib Python package must be available through PyCall.","category":"page"}]
}
