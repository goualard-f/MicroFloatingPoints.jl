<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>A Guided Tour · The MicroFloatingPoints Documentation</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">The MicroFloatingPoints Documentation</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>A Guided Tour</a><ul class="internal"><li><a class="tocitem" href="#Graphics-with-MicroFloatingPoints.MFPPlot"><span>Graphics with <code>MicroFloatingPoints.MFPPlot</code></span></a></li><li><a class="tocitem" href="#Random-floats-with-MicroFloatingPoints.MFPRandom"><span>Random floats with <code>MicroFloatingPoints.MFPRandom</code></span></a></li><li><a class="tocitem" href="#Arithmetic-with-various-precisions"><span>Arithmetic with various precisions</span></a></li></ul></li><li><a class="tocitem" href="../manual/">Manual</a></li><li><a class="tocitem" href="../developer/">Developer Documentation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>A Guided Tour</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>A Guided Tour</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/goualard-f/MicroFloatingPoints.jl/blob/master/docs/src/guided-tour.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="A-guided-tour"><a class="docs-heading-anchor" href="#A-guided-tour">A guided tour</a><a id="A-guided-tour-1"></a><a class="docs-heading-anchor-permalink" href="#A-guided-tour" title="Permalink"></a></h1><p>The <code>MicroFloatingPoints</code> package is organized into four modules:</p><ul><li><code>MicroFloatingPoints</code>: the main module containing the definition of the parameterized type <code>Floatmu</code> and the associated methods;</li><li><code>MicroFloatingPoints.MFPUtils</code>: a module providing miscellaneous utility functions for the <code>Floatmu</code> type;</li><li><code>MicroFloatingPoints.MFPPlot</code>: a module offering various graphical ways to display <code>Floatmu</code> floating-point numbers;</li><li><code>MicroFloatingPoints.MFPRandom</code>: the module overloading <a href="https://docs.julialang.org/en/v1/stdlib/Random/#Base.rand"><code>Random.rand</code></a> to produce <code>Floatmu</code> random values.</li></ul><p>After having correctly installed the package (see <a href="../#Installation">Installation</a>), we start our tour by loading the <code>MicroFloatingPoints</code> module:</p><pre><code class="language-julia-repl">julia&gt; using MicroFloatingPoints</code></pre><p>We can now define a new floating-point type <code>MuFP</code> with 2 bits for the exponent (the first parameter)  and 2 bits for the fractional part (the second parameter):</p><pre><code class="language-julia-repl">julia&gt; MuFP = Floatmu{2,2}
Floatmu{2, 2}</code></pre><p>Such a type is very limited, and a call to <a href="../manual/#Base.floatmax-Union{Tuple{Type{Floatmu{szE, szf}}}, Tuple{szf}, Tuple{szE}} where {szE, szf}"><code>floatmax</code></a> will give us the largest finite float representable:</p><pre><code class="language-julia-repl">julia&gt; floatmax(MuFP)
3.5</code></pre><p>Conversely, we can obtain the smallest positive float in the <code>MuFP</code> format with the <a href="../manual/#MicroFloatingPoints.μ-Union{Tuple{Type{Floatmu{szE, szf}}}, Tuple{szf}, Tuple{szE}} where {szE, szf}"><code>μ</code></a> method:</p><pre><code class="language-julia-repl">julia&gt; μ(MuFP)
0.25</code></pre><p>Note that this value is a <a href="https://en.wikipedia.org/wiki/Denormal_number">subnormal number</a>, which is different and smaller than the smallest normal float, obtained by calling <a href="../manual/#Base.floatmin-Union{Tuple{Type{Floatmu{szE, szf}}}, Tuple{szf}, Tuple{szE}} where {szE, szf}"><code>floatmin</code></a>:</p><pre><code class="language-julia-repl">julia&gt; floatmin(MuFP)
1.0</code></pre><h2 id="Graphics-with-MicroFloatingPoints.MFPPlot"><a class="docs-heading-anchor" href="#Graphics-with-MicroFloatingPoints.MFPPlot">Graphics with <code>MicroFloatingPoints.MFPPlot</code></a><a id="Graphics-with-MicroFloatingPoints.MFPPlot-1"></a><a class="docs-heading-anchor-permalink" href="#Graphics-with-MicroFloatingPoints.MFPPlot" title="Permalink"></a></h2><p>To better assess what we can do with such a small type, let us display all finite representable values on the real line. The <code>Plot</code> module has just the right method:</p><pre><code class="language-julia-repl">julia&gt; using MicroFloatingPoints.MFPPlot

julia&gt; real_line(-floatmax(MuFP),floatmax(MuFP));</code></pre><div style="text-align: center">
<img src="./mufp_realline.svg" alt="Floatmu{2,2} representable finite values" />
</div><p>Since the difference between any pair of <code>MuFP</code> is always greater or equal to μ(MuFP), it becomes apparent why the introduction of <em>subnormal numbers</em> (in purple in the picture above) ensures the property:</p><p class="math-container">\[\forall (a,b)\in\text{MuFP}\colon |b-a| = 0 \iff a=b\]</p><h3 id="Exhaustive-search-for-rounded-additions"><a class="docs-heading-anchor" href="#Exhaustive-search-for-rounded-additions">Exhaustive search for rounded additions</a><a id="Exhaustive-search-for-rounded-additions-1"></a><a class="docs-heading-anchor-permalink" href="#Exhaustive-search-for-rounded-additions" title="Permalink"></a></h3><p>The type <code>MuFP</code> is so small that we can easily perform exhaustive searches with it. For example, we can display graphically whether the sum of any two finite <code>MuFP</code> floats needs to be rounded or not, using the <a href="../manual/#MicroFloatingPoints.inexact-Tuple{}"><code>inexact()</code></a> and <a href="../manual/#MicroFloatingPoints.reset_inexact-Tuple{}"><code>reset_inexact()</code></a> methods to, respectively, test whether the preceding computation needed rounding and to reset the global <em>inexact flag:</em></p><pre><code class="language-julia">plt.figure()
plt.title(&quot;Exhaustive search for rounded sums in Floatmu{2,2}&quot;)
TotalIterator = FloatmuIterator(-floatmax(MuFP),floatmax(MuFP))
N = length(TotalIterator)
Z = zeros(Int,N,N)
let i = 1
    for v1 in TotalIterator
        j = 1
        for v2 in TotalIterator
            reset_inexact()
            v1+v2
            Z[i,j] = Int(inexact())
            j += 1
        end
        i += 1
    end
end
V = collect(TotalIterator)
imshow(Z,origin=&quot;lower&quot;, cmap=&quot;summer&quot;)
plt.yticks(0:(length(V)-1),[string(V[i]) for i in 1:length(V)])
plt.xticks(0:(length(V)-1),[string(V[i]) for i in 1:length(V)],rotation=90);</code></pre><p>Note the use of a <a href="../manual/#MicroFloatingPoints.FloatmuIterator"><code>FloatmuIterator</code></a> to enumerate all floating-point numbers in a range.</p><p>We obtain the following matrix, where a green cell means that the sum of the values in row and column needs no rounding, while a yellow cell means that the result needs rounding to be represented by a <code>Floatmu{2,2}</code>.</p><div style="text-align: center">
<img src="./exhaustive-rounding.svg" alt="Exhautive search for sums of Floatmu{2,2} needing rounding" />
</div><h2 id="Random-floats-with-MicroFloatingPoints.MFPRandom"><a class="docs-heading-anchor" href="#Random-floats-with-MicroFloatingPoints.MFPRandom">Random floats with <code>MicroFloatingPoints.MFPRandom</code></a><a id="Random-floats-with-MicroFloatingPoints.MFPRandom-1"></a><a class="docs-heading-anchor-permalink" href="#Random-floats-with-MicroFloatingPoints.MFPRandom" title="Permalink"></a></h2><p>Let us now draw some <a href="https://en.wikipedia.org/wiki/Bfloat16_floating-point_format"><code>BFloat16</code></a> floats uniformly at random in <span>$[0,1)$</span>. We will use the <code>MicroFloatingPoints.MFPRandom</code> module to overload the <a href="https://docs.julialang.org/en/v1/stdlib/Random/#Base.rand"><code>rand</code></a> method for the type <code>Floatmu</code>.</p><pre><code class="language-julia">using DataStructures
using PyPlot
using MicroFloatingPoints
using MicroFloatingPoints.MFPRandom

BFloat16 = Floatmu{8,7}

ndraws=1000000
plt.figure()
plt.title(&quot;Drawing $ndraws values at random in BFloat16[0,1)&quot;)
T = [rand(BFloat16) for i in 1:ndraws]
Tc = counter(T)</code></pre><p>We can now display the number of times each float was drawn:</p><pre><code class="language-julia">for x in Tc
    (k,v) = x
    plot([k,k],[0,v],marker=&quot;.&quot;,color=&quot;blue&quot;,alpha=0.5)
end
(low,high) = extrema(collect(values(Tc)))
plt.ylim(ymin=0.99*low,ymax=1.01*high)</code></pre><div style="text-align: center">
<img src="./randfreq-bfloat16.svg" alt="Drawing values at random in BFloat16" />
</div><h2 id="Arithmetic-with-various-precisions"><a class="docs-heading-anchor" href="#Arithmetic-with-various-precisions">Arithmetic with various precisions</a><a id="Arithmetic-with-various-precisions-1"></a><a class="docs-heading-anchor-permalink" href="#Arithmetic-with-various-precisions" title="Permalink"></a></h2><p>The <code>BFloat16</code> and <code>Float16</code> formats both represent floating-point numbers with 16 bits. The <code>BFloat16</code> trades precision for a larger range. Let us compare the results obtained when summing the values of a vector with both types:</p><pre><code class="language-julia">BFloat16 = Floatmu{8,7}
MuFloat16 = Floatmu{5,10}
T64 = [rand() for i in 1:1000]
bfT16 = [BFloat16(x) for x in T64]
FT16 = [MuFloat16(x) for x in T64]
println(sum(T64))
println(sum(bfT16))
println(sum(FT16))</code></pre><pre class="documenter-example-output">502.4140523517177
256.0
503.0</pre><p>For small values in <span>$[0,1)$</span>,  the effect of a smaller significand appears drastic. On the other hand, the small range of the type <code>Float16</code> makes it useless for computation with medium to large numbers:</p><pre><code class="language-julia">T64 = [rand(Uniform(min(floatmin(BFloat16),floatmin(MuFloat16)),
            max(floatmax(BFloat16),floatmax(MuFloat16))/100)) for i in 1:100]
bfT16 = [BFloat16(x) for x in T64]
FT16 = [MuFloat16(x) for x in T64]
println(sum(T64))
println(sum(bfT16))
println(sum(FT16))</code></pre><pre class="documenter-example-output">1.791178754416783e38
1.767873234393938e38
Inf</pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../manual/">Manual »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 26 April 2021 08:24">Monday 26 April 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
